/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n}(this, (function (exports) { 'use strict';\n\n    /******************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __spreadArray(to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || Array.prototype.slice.call(from));\r\n    }\n\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n    function createCommonjsModule(fn) {\n      var module = { exports: {} };\n    \treturn fn(module, module.exports), module.exports;\n    }\n\n    var browserPolyfill = createCommonjsModule(function (module) {\n      (function (self) {\n        (function (exports) {\n          var support = {\n            searchParams: 'URLSearchParams' in self,\n            iterable: 'Symbol' in self && 'iterator' in Symbol,\n            blob: 'FileReader' in self && 'Blob' in self && function () {\n              try {\n                new Blob();\n                return true;\n              } catch (e) {\n                return false;\n              }\n            }(),\n            formData: 'FormData' in self,\n            arrayBuffer: 'ArrayBuffer' in self\n          };\n          function isDataView(obj) {\n            return obj && DataView.prototype.isPrototypeOf(obj);\n          }\n          if (support.arrayBuffer) {\n            var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n            var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n            };\n          }\n          function normalizeName(name) {\n            if (typeof name !== 'string') {\n              name = String(name);\n            }\n            if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n              throw new TypeError('Invalid character in header field name');\n            }\n            return name.toLowerCase();\n          }\n          function normalizeValue(value) {\n            if (typeof value !== 'string') {\n              value = String(value);\n            }\n            return value;\n          }\n\n          // Build a destructive iterator for the value list\n          function iteratorFor(items) {\n            var iterator = {\n              next: function () {\n                var value = items.shift();\n                return {\n                  done: value === undefined,\n                  value: value\n                };\n              }\n            };\n            if (support.iterable) {\n              iterator[Symbol.iterator] = function () {\n                return iterator;\n              };\n            }\n            return iterator;\n          }\n          function Headers(headers) {\n            this.map = {};\n            if (headers instanceof Headers) {\n              headers.forEach(function (value, name) {\n                this.append(name, value);\n              }, this);\n            } else if (Array.isArray(headers)) {\n              headers.forEach(function (header) {\n                this.append(header[0], header[1]);\n              }, this);\n            } else if (headers) {\n              Object.getOwnPropertyNames(headers).forEach(function (name) {\n                this.append(name, headers[name]);\n              }, this);\n            }\n          }\n          Headers.prototype.append = function (name, value) {\n            name = normalizeName(name);\n            value = normalizeValue(value);\n            var oldValue = this.map[name];\n            this.map[name] = oldValue ? oldValue + ', ' + value : value;\n          };\n          Headers.prototype['delete'] = function (name) {\n            delete this.map[normalizeName(name)];\n          };\n          Headers.prototype.get = function (name) {\n            name = normalizeName(name);\n            return this.has(name) ? this.map[name] : null;\n          };\n          Headers.prototype.has = function (name) {\n            return this.map.hasOwnProperty(normalizeName(name));\n          };\n          Headers.prototype.set = function (name, value) {\n            this.map[normalizeName(name)] = normalizeValue(value);\n          };\n          Headers.prototype.forEach = function (callback, thisArg) {\n            for (var name in this.map) {\n              if (this.map.hasOwnProperty(name)) {\n                callback.call(thisArg, this.map[name], name, this);\n              }\n            }\n          };\n          Headers.prototype.keys = function () {\n            var items = [];\n            this.forEach(function (value, name) {\n              items.push(name);\n            });\n            return iteratorFor(items);\n          };\n          Headers.prototype.values = function () {\n            var items = [];\n            this.forEach(function (value) {\n              items.push(value);\n            });\n            return iteratorFor(items);\n          };\n          Headers.prototype.entries = function () {\n            var items = [];\n            this.forEach(function (value, name) {\n              items.push([name, value]);\n            });\n            return iteratorFor(items);\n          };\n          if (support.iterable) {\n            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n          }\n          function consumed(body) {\n            if (body.bodyUsed) {\n              return Promise.reject(new TypeError('Already read'));\n            }\n            body.bodyUsed = true;\n          }\n          function fileReaderReady(reader) {\n            return new Promise(function (resolve, reject) {\n              reader.onload = function () {\n                resolve(reader.result);\n              };\n              reader.onerror = function () {\n                reject(reader.error);\n              };\n            });\n          }\n          function readBlobAsArrayBuffer(blob) {\n            var reader = new FileReader();\n            var promise = fileReaderReady(reader);\n            reader.readAsArrayBuffer(blob);\n            return promise;\n          }\n          function readBlobAsText(blob) {\n            var reader = new FileReader();\n            var promise = fileReaderReady(reader);\n            reader.readAsText(blob);\n            return promise;\n          }\n          function readArrayBufferAsText(buf) {\n            var view = new Uint8Array(buf);\n            var chars = new Array(view.length);\n            for (var i = 0; i < view.length; i++) {\n              chars[i] = String.fromCharCode(view[i]);\n            }\n            return chars.join('');\n          }\n          function bufferClone(buf) {\n            if (buf.slice) {\n              return buf.slice(0);\n            } else {\n              var view = new Uint8Array(buf.byteLength);\n              view.set(new Uint8Array(buf));\n              return view.buffer;\n            }\n          }\n          function Body() {\n            this.bodyUsed = false;\n            this._initBody = function (body) {\n              this._bodyInit = body;\n              if (!body) {\n                this._bodyText = '';\n              } else if (typeof body === 'string') {\n                this._bodyText = body;\n              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n                this._bodyBlob = body;\n              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n                this._bodyFormData = body;\n              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this._bodyText = body.toString();\n              } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n                this._bodyArrayBuffer = bufferClone(body.buffer);\n                // IE 10-11 can't handle a DataView body.\n                this._bodyInit = new Blob([this._bodyArrayBuffer]);\n              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n                this._bodyArrayBuffer = bufferClone(body);\n              } else {\n                this._bodyText = body = Object.prototype.toString.call(body);\n              }\n              if (!this.headers.get('content-type')) {\n                if (typeof body === 'string') {\n                  this.headers.set('content-type', 'text/plain;charset=UTF-8');\n                } else if (this._bodyBlob && this._bodyBlob.type) {\n                  this.headers.set('content-type', this._bodyBlob.type);\n                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                  this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n                }\n              }\n            };\n            if (support.blob) {\n              this.blob = function () {\n                var rejected = consumed(this);\n                if (rejected) {\n                  return rejected;\n                }\n                if (this._bodyBlob) {\n                  return Promise.resolve(this._bodyBlob);\n                } else if (this._bodyArrayBuffer) {\n                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n                } else if (this._bodyFormData) {\n                  throw new Error('could not read FormData body as blob');\n                } else {\n                  return Promise.resolve(new Blob([this._bodyText]));\n                }\n              };\n              this.arrayBuffer = function () {\n                if (this._bodyArrayBuffer) {\n                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n                } else {\n                  return this.blob().then(readBlobAsArrayBuffer);\n                }\n              };\n            }\n            this.text = function () {\n              var rejected = consumed(this);\n              if (rejected) {\n                return rejected;\n              }\n              if (this._bodyBlob) {\n                return readBlobAsText(this._bodyBlob);\n              } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n              } else if (this._bodyFormData) {\n                throw new Error('could not read FormData body as text');\n              } else {\n                return Promise.resolve(this._bodyText);\n              }\n            };\n            if (support.formData) {\n              this.formData = function () {\n                return this.text().then(decode);\n              };\n            }\n            this.json = function () {\n              return this.text().then(JSON.parse);\n            };\n            return this;\n          }\n\n          // HTTP methods whose capitalization should be normalized\n          var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n          function normalizeMethod(method) {\n            var upcased = method.toUpperCase();\n            return methods.indexOf(upcased) > -1 ? upcased : method;\n          }\n          function Request(input, options) {\n            options = options || {};\n            var body = options.body;\n            if (input instanceof Request) {\n              if (input.bodyUsed) {\n                throw new TypeError('Already read');\n              }\n              this.url = input.url;\n              this.credentials = input.credentials;\n              if (!options.headers) {\n                this.headers = new Headers(input.headers);\n              }\n              this.method = input.method;\n              this.mode = input.mode;\n              this.signal = input.signal;\n              if (!body && input._bodyInit != null) {\n                body = input._bodyInit;\n                input.bodyUsed = true;\n              }\n            } else {\n              this.url = String(input);\n            }\n            this.credentials = options.credentials || this.credentials || 'same-origin';\n            if (options.headers || !this.headers) {\n              this.headers = new Headers(options.headers);\n            }\n            this.method = normalizeMethod(options.method || this.method || 'GET');\n            this.mode = options.mode || this.mode || null;\n            this.signal = options.signal || this.signal;\n            this.referrer = null;\n            if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n              throw new TypeError('Body not allowed for GET or HEAD requests');\n            }\n            this._initBody(body);\n          }\n          Request.prototype.clone = function () {\n            return new Request(this, {\n              body: this._bodyInit\n            });\n          };\n          function decode(body) {\n            var form = new FormData();\n            body.trim().split('&').forEach(function (bytes) {\n              if (bytes) {\n                var split = bytes.split('=');\n                var name = split.shift().replace(/\\+/g, ' ');\n                var value = split.join('=').replace(/\\+/g, ' ');\n                form.append(decodeURIComponent(name), decodeURIComponent(value));\n              }\n            });\n            return form;\n          }\n          function parseHeaders(rawHeaders) {\n            var headers = new Headers();\n            // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n            // https://tools.ietf.org/html/rfc7230#section-3.2\n            var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n            preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\n              var parts = line.split(':');\n              var key = parts.shift().trim();\n              if (key) {\n                var value = parts.join(':').trim();\n                headers.append(key, value);\n              }\n            });\n            return headers;\n          }\n          Body.call(Request.prototype);\n          function Response(bodyInit, options) {\n            if (!options) {\n              options = {};\n            }\n            this.type = 'default';\n            this.status = options.status === undefined ? 200 : options.status;\n            this.ok = this.status >= 200 && this.status < 300;\n            this.statusText = 'statusText' in options ? options.statusText : 'OK';\n            this.headers = new Headers(options.headers);\n            this.url = options.url || '';\n            this._initBody(bodyInit);\n          }\n          Body.call(Response.prototype);\n          Response.prototype.clone = function () {\n            return new Response(this._bodyInit, {\n              status: this.status,\n              statusText: this.statusText,\n              headers: new Headers(this.headers),\n              url: this.url\n            });\n          };\n          Response.error = function () {\n            var response = new Response(null, {\n              status: 0,\n              statusText: ''\n            });\n            response.type = 'error';\n            return response;\n          };\n          var redirectStatuses = [301, 302, 303, 307, 308];\n          Response.redirect = function (url, status) {\n            if (redirectStatuses.indexOf(status) === -1) {\n              throw new RangeError('Invalid status code');\n            }\n            return new Response(null, {\n              status: status,\n              headers: {\n                location: url\n              }\n            });\n          };\n          exports.DOMException = self.DOMException;\n          try {\n            new exports.DOMException();\n          } catch (err) {\n            exports.DOMException = function (message, name) {\n              this.message = message;\n              this.name = name;\n              var error = Error(message);\n              this.stack = error.stack;\n            };\n            exports.DOMException.prototype = Object.create(Error.prototype);\n            exports.DOMException.prototype.constructor = exports.DOMException;\n          }\n          function fetch(input, init) {\n            return new Promise(function (resolve, reject) {\n              var request = new Request(input, init);\n              if (request.signal && request.signal.aborted) {\n                return reject(new exports.DOMException('Aborted', 'AbortError'));\n              }\n              var xhr = new XMLHttpRequest();\n              function abortXhr() {\n                xhr.abort();\n              }\n              xhr.onload = function () {\n                var options = {\n                  status: xhr.status,\n                  statusText: xhr.statusText,\n                  headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n                };\n                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n                var body = 'response' in xhr ? xhr.response : xhr.responseText;\n                resolve(new Response(body, options));\n              };\n              xhr.onerror = function () {\n                reject(new TypeError('Network request failed'));\n              };\n              xhr.ontimeout = function () {\n                reject(new TypeError('Network request failed'));\n              };\n              xhr.onabort = function () {\n                reject(new exports.DOMException('Aborted', 'AbortError'));\n              };\n              xhr.open(request.method, request.url, true);\n              if (request.credentials === 'include') {\n                xhr.withCredentials = true;\n              } else if (request.credentials === 'omit') {\n                xhr.withCredentials = false;\n              }\n              if ('responseType' in xhr && support.blob) {\n                xhr.responseType = 'blob';\n              }\n              request.headers.forEach(function (value, name) {\n                xhr.setRequestHeader(name, value);\n              });\n              if (request.signal) {\n                request.signal.addEventListener('abort', abortXhr);\n                xhr.onreadystatechange = function () {\n                  // DONE (success or failure)\n                  if (xhr.readyState === 4) {\n                    request.signal.removeEventListener('abort', abortXhr);\n                  }\n                };\n              }\n              xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n            });\n          }\n          fetch.polyfill = true;\n          if (!self.fetch) {\n            self.fetch = fetch;\n            self.Headers = Headers;\n            self.Request = Request;\n            self.Response = Response;\n          }\n          exports.Headers = Headers;\n          exports.Request = Request;\n          exports.Response = Response;\n          exports.fetch = fetch;\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          return exports;\n        })({});\n      })(typeof self !== 'undefined' ? self : commonjsGlobal);\n    });\n\n    var meilisearch_umd = createCommonjsModule(function (module, exports) {\n      (function (global, factory) {\n        factory(exports, browserPolyfill) ;\n      })(commonjsGlobal, function (exports) {\n\n        // Type definitions for meilisearch\n        // Project: https://github.com/meilisearch/meilisearch-js\n        // Definitions by: qdequele <quentin@meilisearch.com> <https://github.com/meilisearch>\n        // Definitions: https://github.com/meilisearch/meilisearch-js\n        // TypeScript Version: ^3.8.3\n\n        /*\r\n         * SEARCH PARAMETERS\r\n         */\n        var MatchingStrategies = {\n          ALL: 'all',\n          LAST: 'last'\n        };\n\n        /******************************************************************************\r\n        Copyright (c) Microsoft Corporation.\r\n          Permission to use, copy, modify, and/or distribute this software for any\r\n        purpose with or without fee is hereby granted.\r\n          THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n        PERFORMANCE OF THIS SOFTWARE.\r\n        ***************************************************************************** */\n        /* global Reflect, Promise */\n\n        var extendStatics = function (d, b) {\n          extendStatics = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (d, b) {\n            d.__proto__ = b;\n          } || function (d, b) {\n            for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n          };\n          return extendStatics(d, b);\n        };\n        function __extends(d, b) {\n          if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n          extendStatics(d, b);\n          function __() {\n            this.constructor = d;\n          }\n          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        }\n        var __assign = function () {\n          __assign = Object.assign || function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n              s = arguments[i];\n              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n          };\n          return __assign.apply(this, arguments);\n        };\n        function __awaiter(thisArg, _arguments, P, generator) {\n          function adopt(value) {\n            return value instanceof P ? value : new P(function (resolve) {\n              resolve(value);\n            });\n          }\n          return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) {\n              try {\n                step(generator.next(value));\n              } catch (e) {\n                reject(e);\n              }\n            }\n            function rejected(value) {\n              try {\n                step(generator[\"throw\"](value));\n              } catch (e) {\n                reject(e);\n              }\n            }\n            function step(result) {\n              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n          });\n        }\n        function __generator(thisArg, body) {\n          var _ = {\n              label: 0,\n              sent: function () {\n                if (t[0] & 1) throw t[1];\n                return t[1];\n              },\n              trys: [],\n              ops: []\n            },\n            f,\n            y,\n            t,\n            g;\n          return g = {\n            next: verb(0),\n            \"throw\": verb(1),\n            \"return\": verb(2)\n          }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n            return this;\n          }), g;\n          function verb(n) {\n            return function (v) {\n              return step([n, v]);\n            };\n          }\n          function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_) try {\n              if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n              if (y = 0, t) op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return {\n                    value: op[1],\n                    done: false\n                  };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f = t = 0;\n            }\n            if (op[0] & 5) throw op[1];\n            return {\n              value: op[0] ? op[1] : void 0,\n              done: true\n            };\n          }\n        }\n        var MeiliSearchCommunicationError = /** @class */\n        function (_super) {\n          __extends(MeiliSearchCommunicationError, _super);\n          function MeiliSearchCommunicationError(message, body, url, stack) {\n            var _this = this;\n            var _a, _b, _c;\n            _this = _super.call(this, message) || this; // Make errors comparison possible. ex: error instanceof MeiliSearchCommunicationError.\n\n            Object.setPrototypeOf(_this, MeiliSearchCommunicationError.prototype);\n            _this.name = 'MeiliSearchCommunicationError';\n            if (body instanceof Response) {\n              _this.message = body.statusText;\n              _this.statusCode = body.status;\n            }\n            if (body instanceof Error) {\n              _this.errno = body.errno;\n              _this.code = body.code;\n            }\n            if (stack) {\n              _this.stack = stack;\n              _this.stack = (_a = _this.stack) === null || _a === void 0 ? void 0 : _a.replace(/(TypeError|FetchError)/, _this.name);\n              _this.stack = (_b = _this.stack) === null || _b === void 0 ? void 0 : _b.replace('Failed to fetch', \"request to \".concat(url, \" failed, reason: connect ECONNREFUSED\"));\n              _this.stack = (_c = _this.stack) === null || _c === void 0 ? void 0 : _c.replace('Not Found', \"Not Found: \".concat(url));\n            } else {\n              if (Error.captureStackTrace) {\n                Error.captureStackTrace(_this, MeiliSearchCommunicationError);\n              }\n            }\n            return _this;\n          }\n          return MeiliSearchCommunicationError;\n        }(Error);\n        var MeiliSearchApiError = /** @class */\n        function (_super) {\n          __extends(class_1, _super);\n          function class_1(error, status) {\n            var _this = _super.call(this, error.message) || this; // Make errors comparison possible. ex: error instanceof MeiliSearchApiError.\n\n            Object.setPrototypeOf(_this, MeiliSearchApiError.prototype);\n            _this.name = 'MeiliSearchApiError';\n            _this.code = error.code;\n            _this.type = error.type;\n            _this.link = error.link;\n            _this.message = error.message;\n            _this.httpStatus = status;\n            if (Error.captureStackTrace) {\n              Error.captureStackTrace(_this, MeiliSearchApiError);\n            }\n            return _this;\n          }\n          return class_1;\n        }(Error);\n        function httpResponseErrorHandler(response) {\n          return __awaiter(this, void 0, void 0, function () {\n            var responseBody;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  if (!!response.ok) return [3\n                  /*break*/, 5];\n                  responseBody = void 0;\n                  _a.label = 1;\n                case 1:\n                  _a.trys.push([1, 3,, 4]);\n                  return [4\n                  /*yield*/, response.json()];\n                case 2:\n                  // If it is not possible to parse the return body it means there is none\n                  // In which case it is a communication error with the Meilisearch instance\n                  responseBody = _a.sent();\n                  return [3\n                  /*break*/, 4];\n                case 3:\n                  _a.sent(); // Not sure on how to test this part of the code.\n\n                  throw new MeiliSearchCommunicationError(response.statusText, response, response.url);\n                case 4:\n                  // If the body is parsable, then it means Meilisearch returned a body with\n                  // information on the error.\n                  throw new MeiliSearchApiError(responseBody, response.status);\n                case 5:\n                  return [2\n                  /*return*/, response];\n              }\n            });\n          });\n        }\n        function httpErrorHandler(response, stack, url) {\n          if (response.name !== 'MeiliSearchApiError') {\n            throw new MeiliSearchCommunicationError(response.message, response, url, stack);\n          }\n          throw response;\n        }\n        var MeiliSearchError = /** @class */\n        function (_super) {\n          __extends(MeiliSearchError, _super);\n          function MeiliSearchError(message) {\n            var _this = _super.call(this, message) || this; // Make errors comparison possible. ex: error instanceof MeiliSearchError.\n\n            Object.setPrototypeOf(_this, MeiliSearchError.prototype);\n            _this.name = 'MeiliSearchError';\n            if (Error.captureStackTrace) {\n              Error.captureStackTrace(_this, MeiliSearchError);\n            }\n            return _this;\n          }\n          return MeiliSearchError;\n        }(Error);\n        var MeiliSearchTimeOutError = /** @class */\n        function (_super) {\n          __extends(MeiliSearchTimeOutError, _super);\n          function MeiliSearchTimeOutError(message) {\n            var _this = _super.call(this, message) || this; // Make errors comparison possible. ex: error instanceof MeiliSearchTimeOutError.\n\n            Object.setPrototypeOf(_this, MeiliSearchTimeOutError.prototype);\n            _this.name = 'MeiliSearchTimeOutError';\n            if (Error.captureStackTrace) {\n              Error.captureStackTrace(_this, MeiliSearchTimeOutError);\n            }\n            return _this;\n          }\n          return MeiliSearchTimeOutError;\n        }(Error);\n\n        /**\r\n         * Removes undefined entries from object\r\n         */\n\n        function removeUndefinedFromObject(obj) {\n          return Object.entries(obj).reduce(function (acc, curEntry) {\n            var key = curEntry[0],\n              val = curEntry[1];\n            if (val !== undefined) acc[key] = val;\n            return acc;\n          }, {});\n        }\n        function sleep(ms) {\n          return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/, new Promise(function (resolve) {\n                    return setTimeout(resolve, ms);\n                  })];\n                case 1:\n                  return [2\n                  /*return*/, _a.sent()];\n              }\n            });\n          });\n        }\n        function addProtocolIfNotPresent(host) {\n          if (!(host.startsWith('https://') || host.startsWith('http://'))) {\n            return \"http://\".concat(host);\n          }\n          return host;\n        }\n        function addTrailingSlash(url) {\n          if (!url.endsWith('/')) {\n            url += '/';\n          }\n          return url;\n        }\n        var PACKAGE_VERSION = '0.30.0';\n        function toQueryParams(parameters) {\n          var params = Object.keys(parameters);\n          var queryParams = params.reduce(function (acc, key) {\n            var _a, _b, _c;\n            var value = parameters[key];\n            if (value === undefined) {\n              return acc;\n            } else if (Array.isArray(value)) {\n              return __assign(__assign({}, acc), (_a = {}, _a[key] = value.join(','), _a));\n            } else if (value instanceof Date) {\n              return __assign(__assign({}, acc), (_b = {}, _b[key] = value.toISOString(), _b));\n            }\n            return __assign(__assign({}, acc), (_c = {}, _c[key] = value, _c));\n          }, {});\n          return queryParams;\n        }\n        function constructHostURL(host) {\n          try {\n            host = addProtocolIfNotPresent(host);\n            host = addTrailingSlash(host);\n            return host;\n          } catch (e) {\n            throw new MeiliSearchError('The provided host is not valid.');\n          }\n        }\n        function createHeaders(config) {\n          var agentHeader = 'X-Meilisearch-Client';\n          var packageAgent = \"Meilisearch JavaScript (v\".concat(PACKAGE_VERSION, \")\");\n          var contentType = 'Content-Type';\n          config.headers = config.headers || {};\n          var headers = Object.assign({}, config.headers); // Create a hard copy and not a reference to config.headers\n\n          if (config.apiKey) {\n            headers['Authorization'] = \"Bearer \".concat(config.apiKey);\n          }\n          if (!config.headers[contentType]) {\n            headers['Content-Type'] = 'application/json';\n          } // Creates the custom user agent with information on the package used.\n\n          if (config.clientAgents && Array.isArray(config.clientAgents)) {\n            var clients = config.clientAgents.concat(packageAgent);\n            headers[agentHeader] = clients.join(' ; ');\n          } else if (config.clientAgents && !Array.isArray(config.clientAgents)) {\n            // If the header is defined but not an array\n            throw new MeiliSearchError(\"Meilisearch: The header \\\"\".concat(agentHeader, \"\\\" should be an array of string(s).\\n\"));\n          } else {\n            headers[agentHeader] = packageAgent;\n          }\n          return headers;\n        }\n        var HttpRequests = /** @class */\n        function () {\n          function HttpRequests(config) {\n            this.headers = createHeaders(config);\n            try {\n              var host = constructHostURL(config.host);\n              this.url = new URL(host);\n            } catch (e) {\n              throw new MeiliSearchError('The provided host is not valid.');\n            }\n          }\n          HttpRequests.prototype.request = function (_a) {\n            var method = _a.method,\n              url = _a.url,\n              params = _a.params,\n              body = _a.body,\n              config = _a.config;\n            return __awaiter(this, void 0, void 0, function () {\n              var constructURL, queryParams_1, response, parsedBody, e_1, stack;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    constructURL = new URL(url, this.url);\n                    if (params) {\n                      queryParams_1 = new URLSearchParams();\n                      Object.keys(params).filter(function (x) {\n                        return params[x] !== null;\n                      }).map(function (x) {\n                        return queryParams_1.set(x, params[x]);\n                      });\n                      constructURL.search = queryParams_1.toString();\n                    }\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, 4,, 5]);\n                    return [4\n                    /*yield*/, fetch(constructURL.toString(), __assign(__assign({}, config), {\n                      method: method,\n                      body: JSON.stringify(body),\n                      headers: this.headers\n                    })).then(function (res) {\n                      return httpResponseErrorHandler(res);\n                    })];\n                  case 2:\n                    response = _b.sent();\n                    return [4\n                    /*yield*/, response.json()[\"catch\"](function () {\n                      return undefined;\n                    })];\n                  case 3:\n                    parsedBody = _b.sent();\n                    return [2\n                    /*return*/, parsedBody];\n                  case 4:\n                    e_1 = _b.sent();\n                    stack = e_1.stack;\n                    httpErrorHandler(e_1, stack, constructURL.toString());\n                    return [3\n                    /*break*/, 5];\n                  case 5:\n                    return [2\n                    /*return*/];\n                }\n              });\n            });\n          };\n\n          HttpRequests.prototype.get = function (url, params, config) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.request({\n                      method: 'GET',\n                      url: url,\n                      params: params,\n                      config: config\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          HttpRequests.prototype.post = function (url, data, params, config) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.request({\n                      method: 'POST',\n                      url: url,\n                      body: data,\n                      params: params,\n                      config: config\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          HttpRequests.prototype.put = function (url, data, params, config) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.request({\n                      method: 'PUT',\n                      url: url,\n                      body: data,\n                      params: params,\n                      config: config\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          HttpRequests.prototype.patch = function (url, data, params, config) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.request({\n                      method: 'PATCH',\n                      url: url,\n                      body: data,\n                      params: params,\n                      config: config\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          HttpRequests.prototype[\"delete\"] = function (url, data, params, config) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.request({\n                      method: 'DELETE',\n                      url: url,\n                      body: data,\n                      params: params,\n                      config: config\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          return HttpRequests;\n        }();\n        var EnqueuedTask = /** @class */\n        function () {\n          function EnqueuedTask(task) {\n            this.taskUid = task.taskUid;\n            this.indexUid = task.indexUid;\n            this.status = task.status;\n            this.type = task.type;\n            this.enqueuedAt = new Date(task.enqueuedAt);\n          }\n          return EnqueuedTask;\n        }();\n        var Task = /** @class */\n        function () {\n          function Task(task) {\n            this.indexUid = task.indexUid;\n            this.status = task.status;\n            this.type = task.type;\n            this.uid = task.uid;\n            this.details = task.details;\n            this.canceledBy = task.canceledBy;\n            this.error = task.error;\n            this.duration = task.duration;\n            this.startedAt = new Date(task.startedAt);\n            this.enqueuedAt = new Date(task.enqueuedAt);\n            this.finishedAt = new Date(task.finishedAt);\n          }\n          return Task;\n        }();\n        var TaskClient = /** @class */\n        function () {\n          function TaskClient(config) {\n            this.httpRequest = new HttpRequests(config);\n          }\n          /**\r\n           * Get one task\r\n           *\r\n           * @param  {number} uid - unique identifier of the task\r\n           *\r\n           * @returns { Promise<Task> }\r\n           */\n\n          TaskClient.prototype.getTask = function (uid) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, taskItem;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"tasks/\".concat(uid);\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    taskItem = _a.sent();\n                    return [2\n                    /*return*/, new Task(taskItem)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get tasks\r\n           *\r\n           * @param  {TasksQuery} [parameters={}] - Parameters to browse the tasks\r\n           *\r\n           * @returns {Promise<TasksResults>} - Promise containing all tasks\r\n           */\n\n          TaskClient.prototype.getTasks = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url, tasks;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"tasks\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url, toQueryParams(parameters))];\n                  case 1:\n                    tasks = _a.sent();\n                    return [2\n                    /*return*/, __assign(__assign({}, tasks), {\n                      results: tasks.results.map(function (task) {\n                        return new Task(task);\n                      })\n                    })];\n                }\n              });\n            });\n          };\n          /**\r\n           * Wait for a task to be processed.\r\n           *\r\n           * @param {number} taskUid Task identifier\r\n           * @param {WaitOptions} options Additional configuration options\r\n           *\r\n           * @returns {Promise<Task>} Promise returning a task after it has been processed\r\n           */\n\n          TaskClient.prototype.waitForTask = function (taskUid, _a) {\n            var _b = _a === void 0 ? {} : _a,\n              _c = _b.timeOutMs,\n              timeOutMs = _c === void 0 ? 5000 : _c,\n              _d = _b.intervalMs,\n              intervalMs = _d === void 0 ? 50 : _d;\n            return __awaiter(this, void 0, void 0, function () {\n              var startingTime, response;\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    startingTime = Date.now();\n                    _e.label = 1;\n                  case 1:\n                    if (!(Date.now() - startingTime < timeOutMs)) return [3\n                    /*break*/, 4];\n                    return [4\n                    /*yield*/, this.getTask(taskUid)];\n                  case 2:\n                    response = _e.sent();\n                    if (![\"enqueued\"\n                    /* TASK_ENQUEUED */, \"processing\"\n                    /* TASK_PROCESSING */].includes(response.status)) return [2\n                    /*return*/, response];\n                    return [4\n                    /*yield*/, sleep(intervalMs)];\n                  case 3:\n                    _e.sent();\n                    return [3\n                    /*break*/, 1];\n                  case 4:\n                    throw new MeiliSearchTimeOutError(\"timeout of \".concat(timeOutMs, \"ms has exceeded on process \").concat(taskUid, \" when waiting a task to be resolved.\"));\n                }\n              });\n            });\n          };\n          /**\r\n           * Waits for multiple tasks to be processed\r\n           *\r\n           * @param {number[]} taskUids Tasks identifier list\r\n           * @param {WaitOptions} options Wait options\r\n           *\r\n           * @returns {Promise<Task[]>} Promise returning a list of tasks after they have been processed\r\n           */\n\n          TaskClient.prototype.waitForTasks = function (taskUids, _a) {\n            var _b = _a === void 0 ? {} : _a,\n              _c = _b.timeOutMs,\n              timeOutMs = _c === void 0 ? 5000 : _c,\n              _d = _b.intervalMs,\n              intervalMs = _d === void 0 ? 50 : _d;\n            return __awaiter(this, void 0, void 0, function () {\n              var tasks, _i, taskUids_1, taskUid, task;\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    tasks = [];\n                    _i = 0, taskUids_1 = taskUids;\n                    _e.label = 1;\n                  case 1:\n                    if (!(_i < taskUids_1.length)) return [3\n                    /*break*/, 4];\n                    taskUid = taskUids_1[_i];\n                    return [4\n                    /*yield*/, this.waitForTask(taskUid, {\n                      timeOutMs: timeOutMs,\n                      intervalMs: intervalMs\n                    })];\n                  case 2:\n                    task = _e.sent();\n                    tasks.push(task);\n                    _e.label = 3;\n                  case 3:\n                    _i++;\n                    return [3\n                    /*break*/, 1];\n                  case 4:\n                    return [2\n                    /*return*/, tasks];\n                }\n              });\n            });\n          };\n          /**\r\n           * Cancel a list of enqueued or processing tasks.\r\n           * @memberof Tasks\r\n           * @method cancelTasks\r\n           * @param {CancelTasksQuery} [parameters={}] - Parameters to filter the tasks.\r\n           *\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          TaskClient.prototype.cancelTasks = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"tasks/cancel\";\n                    return [4\n                    /*yield*/, this.httpRequest.post(url, {}, toQueryParams(parameters))];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete a list tasks.\r\n           * @memberof Tasks\r\n           * @method deleteTasks\r\n           * @param {DeleteTasksQuery} [parameters={}] - Parameters to filter the tasks.\r\n           *\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          TaskClient.prototype.deleteTasks = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"tasks\";\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url, {}, toQueryParams(parameters))];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          return TaskClient;\n        }();\n\n        /*\r\n         * Bundle: MeiliSearch / Indexes\r\n         * Project: MeiliSearch - Javascript API\r\n         * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n         * Copyright: 2019, MeiliSearch\r\n         */\n\n        var Index = /** @class */\n        function () {\n          /**\r\n           * @param {Config} config Request configuration options\r\n           * @param {string} uid UID of the index\r\n           * @param {string} [primaryKey] Primary Key of the index\r\n           */\n          function Index(config, uid, primaryKey) {\n            this.uid = uid;\n            this.primaryKey = primaryKey;\n            this.httpRequest = new HttpRequests(config);\n            this.tasks = new TaskClient(config);\n          } ///\n          /// SEARCH\n          ///\n\n          /**\r\n           * Search for documents into an index\r\n           * @memberof Index\r\n           * @method search\r\n           * @template T\r\n           * @param {string | null} query? Query string\r\n           * @param {SearchParams} options? Search options\r\n           * @param {Partial<Request>} config? Additional request configuration options\r\n           * @returns {Promise<SearchResponse<T>>} Promise containing the search response\r\n           */\n\n          Index.prototype.search = function (query, options, config) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/search\");\n                    return [4\n                    /*yield*/, this.httpRequest.post(url, removeUndefinedFromObject(__assign({\n                      q: query\n                    }, options)), undefined, config)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Search for documents into an index using the GET method\r\n           * @memberof Index\r\n           * @method search\r\n           * @template T\r\n           * @param {string | null} query? Query string\r\n           * @param {SearchParams} options? Search options\r\n           * @param {Partial<Request>} config? Additional request configuration options\r\n           * @returns {Promise<SearchResponse<T>>} Promise containing the search response\r\n           */\n\n          Index.prototype.searchGet = function (query, options, config) {\n            var _a, _b, _c, _d, _e;\n            return __awaiter(this, void 0, void 0, function () {\n              var url, parseFilter, getParams;\n              return __generator(this, function (_f) {\n                switch (_f.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/search\");\n                    parseFilter = function parseFilter(filter) {\n                      if (typeof filter === 'string') return filter;else if (Array.isArray(filter)) throw new MeiliSearchError('The filter query parameter should be in string format when using searchGet');else return undefined;\n                    };\n                    getParams = __assign(__assign({\n                      q: query\n                    }, options), {\n                      filter: parseFilter(options === null || options === void 0 ? void 0 : options.filter),\n                      sort: (_a = options === null || options === void 0 ? void 0 : options.sort) === null || _a === void 0 ? void 0 : _a.join(','),\n                      facets: (_b = options === null || options === void 0 ? void 0 : options.facets) === null || _b === void 0 ? void 0 : _b.join(','),\n                      attributesToRetrieve: (_c = options === null || options === void 0 ? void 0 : options.attributesToRetrieve) === null || _c === void 0 ? void 0 : _c.join(','),\n                      attributesToCrop: (_d = options === null || options === void 0 ? void 0 : options.attributesToCrop) === null || _d === void 0 ? void 0 : _d.join(','),\n                      attributesToHighlight: (_e = options === null || options === void 0 ? void 0 : options.attributesToHighlight) === null || _e === void 0 ? void 0 : _e.join(',')\n                    });\n                    return [4\n                    /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(getParams), config)];\n                  case 1:\n                    return [2\n                    /*return*/, _f.sent()];\n                }\n              });\n            });\n          }; ///\n          /// INDEX\n          ///\n\n          /**\r\n           * Get index information.\r\n           * @memberof Index\r\n           * @method getRawInfo\r\n           *\r\n           * @returns {Promise<IndexObject>} Promise containing index information\r\n           */\n\n          Index.prototype.getRawInfo = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, res;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid);\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    res = _a.sent();\n                    this.primaryKey = res.primaryKey;\n                    this.updatedAt = new Date(res.updatedAt);\n                    this.createdAt = new Date(res.createdAt);\n                    return [2\n                    /*return*/, res];\n                }\n              });\n            });\n          };\n          /**\r\n           * Fetch and update Index information.\r\n           * @memberof Index\r\n           * @method fetchInfo\r\n           * @returns {Promise<this>} Promise to the current Index object with updated information\r\n           */\n\n          Index.prototype.fetchInfo = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.getRawInfo()];\n                  case 1:\n                    _a.sent();\n                    return [2\n                    /*return*/, this];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get Primary Key.\r\n           * @memberof Index\r\n           * @method fetchPrimaryKey\r\n           * @returns {Promise<string | undefined>} Promise containing the Primary Key of the index\r\n           */\n\n          Index.prototype.fetchPrimaryKey = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var _a;\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    _a = this;\n                    return [4\n                    /*yield*/, this.getRawInfo()];\n                  case 1:\n                    _a.primaryKey = _b.sent().primaryKey;\n                    return [2\n                    /*return*/, this.primaryKey];\n                }\n              });\n            });\n          };\n          /**\r\n           * Create an index.\r\n           * @memberof Index\r\n           * @method create\r\n           * @template T\r\n           * @param {string} uid Unique identifier of the Index\r\n           * @param {IndexOptions} options Index options\r\n           * @param {Config} config Request configuration options\r\n           * @returns {Promise<EnqueuedTask>} Newly created Index object\r\n           */\n\n          Index.create = function (uid, options, config) {\n            if (options === void 0) {\n              options = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url, req, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes\";\n                    req = new HttpRequests(config);\n                    return [4\n                    /*yield*/, req.post(url, __assign(__assign({}, options), {\n                      uid: uid\n                    }))];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update an index.\r\n           * @memberof Index\r\n           * @method update\r\n           * @param {IndexOptions} data Data to update\r\n           * @returns {Promise<this>} Promise to the current Index object with updated information\r\n           */\n\n          Index.prototype.update = function (data) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid);\n                    return [4\n                    /*yield*/, this.httpRequest.patch(url, data)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete an index.\r\n           * @memberof Index\r\n           * @method delete\r\n           * @returns {Promise<void>} Promise which resolves when index is deleted successfully\r\n           */\n\n          Index.prototype[\"delete\"] = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid);\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          }; ///\n          /// TASKS\n          ///\n\n          /**\r\n           * Get the list of all the tasks of the index.\r\n           *\r\n           * @memberof Indexes\r\n           * @method getTasks\r\n           * @param {TasksQuery} [parameters={}] - Parameters to browse the tasks\r\n           *\r\n           * @returns {Promise<TasksResults>} - Promise containing all tasks\r\n           */\n\n          Index.prototype.getTasks = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.getTasks(__assign(__assign({}, parameters), {\n                      indexUids: [this.uid]\n                    }))];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get one task of the index.\r\n           *\r\n           * @memberof Indexes\r\n           * @method getTask\r\n           * @param {number} taskUid - Task identifier\r\n           *\r\n           * @returns {Promise<Task>} - Promise containing a task\r\n           */\n\n          Index.prototype.getTask = function (taskUid) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.getTask(taskUid)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Wait for multiple tasks to be processed.\r\n           *\r\n           * @memberof Indexes\r\n           * @method waitForTasks\r\n           * @param {number[]} taskUids - Tasks identifier\r\n           * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n           *\r\n           * @returns {Promise<Task[]>} - Promise containing an array of tasks\r\n           */\n\n          Index.prototype.waitForTasks = function (taskUids, _a) {\n            var _b = _a === void 0 ? {} : _a,\n              _c = _b.timeOutMs,\n              timeOutMs = _c === void 0 ? 5000 : _c,\n              _d = _b.intervalMs,\n              intervalMs = _d === void 0 ? 50 : _d;\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.waitForTasks(taskUids, {\n                      timeOutMs: timeOutMs,\n                      intervalMs: intervalMs\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _e.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Wait for a task to be processed.\r\n           *\r\n           * @memberof Indexes\r\n           * @method waitForTask\r\n           * @param {number} taskUid - Task identifier\r\n           * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n           *\r\n           * @returns {Promise<Task>} - Promise containing an array of tasks\r\n           */\n\n          Index.prototype.waitForTask = function (taskUid, _a) {\n            var _b = _a === void 0 ? {} : _a,\n              _c = _b.timeOutMs,\n              timeOutMs = _c === void 0 ? 5000 : _c,\n              _d = _b.intervalMs,\n              intervalMs = _d === void 0 ? 50 : _d;\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.waitForTask(taskUid, {\n                      timeOutMs: timeOutMs,\n                      intervalMs: intervalMs\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _e.sent()];\n                }\n              });\n            });\n          }; ///\n          /// STATS\n          ///\n\n          /**\r\n           * get stats of an index\r\n           * @memberof Index\r\n           * @method getStats\r\n           * @returns {Promise<IndexStats>} Promise containing object with stats of the index\r\n           */\n\n          Index.prototype.getStats = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/stats\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          }; ///\n          /// DOCUMENTS\n          ///\n\n          /**\r\n           * get documents of an index\r\n           * @memberof Index\r\n           * @method getDocuments\r\n           * @template T\r\n           * @param {DocumentsQuery<T>} [parameters={}] Parameters to browse the documents\r\n           * @returns {Promise<DocumentsResults<T>>>} Promise containing Document responses\r\n           */\n\n          Index.prototype.getDocuments = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url, fields;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents\");\n                    fields = function () {\n                      var _a;\n                      if (Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields)) {\n                        return (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(',');\n                      }\n                      return undefined;\n                    }();\n                    return [4\n                    /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(__assign(__assign({}, parameters), {\n                      fields: fields\n                    })))];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get one document\r\n           * @memberof Index\r\n           * @method getDocument\r\n           * @template T\r\n           * @param {string | number} documentId Document ID\r\n           * @param {DocumentQuery<T>} [parameters={}] Parameters applied on a document\r\n           * @returns {Promise<Document<T>>} Promise containing Document response\r\n           */\n\n          Index.prototype.getDocument = function (documentId, parameters) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, fields;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\n                    fields = function () {\n                      var _a;\n                      if (Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields)) {\n                        return (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(',');\n                      }\n                      return undefined;\n                    }();\n                    return [4\n                    /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(__assign(__assign({}, parameters), {\n                      fields: fields\n                    })))];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Add or replace multiples documents to an index\r\n           * @memberof Index\r\n           * @method addDocuments\r\n           * @template T\r\n           * @param {Array<Document<T>>} documents Array of Document objects to add/replace\r\n           * @param {DocumentOptions} options? Options on document addition\r\n           *\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.addDocuments = function (documents, options) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents\");\n                    return [4\n                    /*yield*/, this.httpRequest.post(url, documents, options)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Add or replace multiples documents to an index in batches\r\n           * @memberof Index\r\n           * @method addDocumentsInBatches\r\n           * @template T\r\n           * @param {Array<Document<T>>} documents Array of Document objects to add/replace\r\n           * @param {number} batchSize Size of the batch\r\n           * @param {DocumentOptions} options? Options on document addition\r\n           * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued task objects for each batch\r\n           */\n\n          Index.prototype.addDocumentsInBatches = function (documents, batchSize, options) {\n            if (batchSize === void 0) {\n              batchSize = 1000;\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var updates, i, _a, _b;\n              return __generator(this, function (_c) {\n                switch (_c.label) {\n                  case 0:\n                    updates = [];\n                    i = 0;\n                    _c.label = 1;\n                  case 1:\n                    if (!(i < documents.length)) return [3\n                    /*break*/, 4];\n                    _b = (_a = updates).push;\n                    return [4\n                    /*yield*/, this.addDocuments(documents.slice(i, i + batchSize), options)];\n                  case 2:\n                    _b.apply(_a, [_c.sent()]);\n                    _c.label = 3;\n                  case 3:\n                    i += batchSize;\n                    return [3\n                    /*break*/, 1];\n                  case 4:\n                    return [2\n                    /*return*/, updates];\n                }\n              });\n            });\n          };\n          /**\r\n           * Add or update multiples documents to an index\r\n           * @memberof Index\r\n           * @method updateDocuments\r\n           * @param {Array<Document<Partial<T>>>} documents Array of Document objects to add/update\r\n           * @param {DocumentOptions} options? Options on document update\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateDocuments = function (documents, options) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, documents, options)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Add or update multiples documents to an index in batches\r\n           * @memberof Index\r\n           * @method updateDocuments\r\n           * @template T\r\n           * @param {Array<Document<T>>} documents Array of Document objects to add/update\r\n           * @param {number} batchSize Size of the batch\r\n           * @param {DocumentOptions} options? Options on document update\r\n           * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued task objects for each batch\r\n           */\n\n          Index.prototype.updateDocumentsInBatches = function (documents, batchSize, options) {\n            if (batchSize === void 0) {\n              batchSize = 1000;\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var updates, i, _a, _b;\n              return __generator(this, function (_c) {\n                switch (_c.label) {\n                  case 0:\n                    updates = [];\n                    i = 0;\n                    _c.label = 1;\n                  case 1:\n                    if (!(i < documents.length)) return [3\n                    /*break*/, 4];\n                    _b = (_a = updates).push;\n                    return [4\n                    /*yield*/, this.updateDocuments(documents.slice(i, i + batchSize), options)];\n                  case 2:\n                    _b.apply(_a, [_c.sent()]);\n                    _c.label = 3;\n                  case 3:\n                    i += batchSize;\n                    return [3\n                    /*break*/, 1];\n                  case 4:\n                    return [2\n                    /*return*/, updates];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete one document\r\n           * @memberof Index\r\n           * @method deleteDocument\r\n           * @param {string | number} documentId Id of Document to delete\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.deleteDocument = function (documentId) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete multiples documents of an index\r\n           * @memberof Index\r\n           * @method deleteDocuments\r\n           * @param {string[] | number[]} documentsIds Array of Document Ids to delete\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.deleteDocuments = function (documentsIds) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents/delete-batch\");\n                    return [4\n                    /*yield*/, this.httpRequest.post(url, documentsIds)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete all documents of an index\r\n           * @memberof Index\r\n           * @method deleteAllDocuments\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.deleteAllDocuments = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/documents\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// SETTINGS\n          ///\n\n          /**\r\n           * Retrieve all settings\r\n           * @memberof Index\r\n           * @method getSettings\r\n           * @returns {Promise<Settings>} Promise containing Settings object\r\n           */\n\n          Index.prototype.getSettings = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update all settings\r\n           * Any parameters not provided will be left unchanged.\r\n           * @memberof Index\r\n           * @method updateSettings\r\n           * @param {Settings} settings Object containing parameters with their updated values\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateSettings = function (settings) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings\");\n                    return [4\n                    /*yield*/, this.httpRequest.patch(url, settings)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueued = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset settings.\r\n           * @memberof Index\r\n           * @method resetSettings\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetSettings = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// PAGINATION SETTINGS\n          ///\n\n          /**\r\n           * Get the pagination settings.\r\n           * @memberof Index\r\n           * @method getPagination\r\n           * @returns {Promise<PaginationSetting>} Promise containing object of pagination settings\r\n           */\n\n          Index.prototype.getPagination = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/pagination\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the pagination settings.\r\n           * @memberof Index\r\n           * @method updatePagination\r\n           * @param {PaginationSettings} pagination Pagination object\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updatePagination = function (pagination) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/pagination\");\n                    return [4\n                    /*yield*/, this.httpRequest.patch(url, pagination)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the pagination settings.\r\n           * @memberof Index\r\n           * @method resetPagination\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetPagination = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/pagination\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          }; ///\n          /// SYNONYMS\n          ///\n\n          /**\r\n           * Get the list of all synonyms\r\n           * @memberof Index\r\n           * @method getSynonyms\r\n           * @returns {Promise<object>} Promise containing object of synonym mappings\r\n           */\n\n          Index.prototype.getSynonyms = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the list of synonyms. Overwrite the old list.\r\n           * @memberof Index\r\n           * @method updateSynonyms\r\n           * @param {Synonyms} synonyms Mapping of synonyms with their associated words\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateSynonyms = function (synonyms) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, synonyms)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the synonym list to be empty again\r\n           * @memberof Index\r\n           * @method resetSynonyms\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetSynonyms = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// STOP WORDS\n          ///\n\n          /**\r\n           * Get the list of all stop-words\r\n           * @memberof Index\r\n           * @method getStopWords\r\n           * @returns {Promise<string[]>} Promise containing array of stop-words\r\n           */\n\n          Index.prototype.getStopWords = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the list of stop-words. Overwrite the old list.\r\n           * @memberof Index\r\n           * @method updateStopWords\r\n           * @param {StopWords} stopWords Array of strings that contains the stop-words.\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateStopWords = function (stopWords) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, stopWords)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the stop-words list to be empty again\r\n           * @memberof Index\r\n           * @method resetStopWords\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetStopWords = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// RANKING RULES\n          ///\n\n          /**\r\n           * Get the list of all ranking-rules\r\n           * @memberof Index\r\n           * @method getRankingRules\r\n           * @returns {Promise<string[]>} Promise containing array of ranking-rules\r\n           */\n\n          Index.prototype.getRankingRules = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the list of ranking-rules. Overwrite the old list.\r\n           * @memberof Index\r\n           * @method updateRankingRules\r\n           * @param {RankingRules} rankingRules Array that contain ranking rules sorted by order of importance.\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateRankingRules = function (rankingRules) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, rankingRules)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the ranking rules list to its default value\r\n           * @memberof Index\r\n           * @method resetRankingRules\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetRankingRules = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// DISTINCT ATTRIBUTE\n          ///\n\n          /**\r\n           * Get the distinct-attribute\r\n           * @memberof Index\r\n           * @method getDistinctAttribute\r\n           * @returns {Promise<string | null>} Promise containing the distinct-attribute of the index\r\n           */\n\n          Index.prototype.getDistinctAttribute = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the distinct-attribute.\r\n           * @memberof Index\r\n           * @method updateDistinctAttribute\r\n           * @param {DistinctAttribute} distinctAttribute Field name of the distinct-attribute\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateDistinctAttribute = function (distinctAttribute) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, distinctAttribute)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the distinct-attribute.\r\n           * @memberof Index\r\n           * @method resetDistinctAttribute\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetDistinctAttribute = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// FILTERABLE ATTRIBUTES\n          ///\n\n          /**\r\n           * Get the filterable-attributes\r\n           * @memberof Index\r\n           * @method getFilterableAttributes\r\n           * @returns {Promise<string[]>} Promise containing an array of filterable-attributes\r\n           */\n\n          Index.prototype.getFilterableAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the filterable-attributes.\r\n           * @memberof Index\r\n           * @method updateFilterableAttributes\r\n           * @param {FilterableAttributes} filterableAttributes Array of strings containing the attributes that can be used as filters at query time\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateFilterableAttributes = function (filterableAttributes) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, filterableAttributes)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the filterable-attributes.\r\n           * @memberof Index\r\n           * @method resetFilterableAttributes\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetFilterableAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// SORTABLE ATTRIBUTES\n          ///\n\n          /**\r\n           * Get the sortable-attributes\r\n           * @memberof Index\r\n           * @method getSortableAttributes\r\n           * @returns {Promise<string[]>} Promise containing array of sortable-attributes\r\n           */\n\n          Index.prototype.getSortableAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the sortable-attributes.\r\n           * @memberof Index\r\n           * @method updateSortableAttributes\r\n           * @param {SortableAttributes} sortableAttributes Array of strings containing the attributes that can be used to sort search results at query time\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateSortableAttributes = function (sortableAttributes) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, sortableAttributes)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the sortable-attributes.\r\n           * @memberof Index\r\n           * @method resetSortableAttributes\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetSortableAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// SEARCHABLE ATTRIBUTE\n          ///\n\n          /**\r\n           * Get the searchable-attributes\r\n           * @memberof Index\r\n           * @method getSearchableAttributes\r\n           * @returns {Promise<string[]>} Promise containing array of searchable-attributes\r\n           */\n\n          Index.prototype.getSearchableAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the searchable-attributes.\r\n           * @memberof Index\r\n           * @method updateSearchableAttributes\r\n           * @param {SearchableAttributes} searchableAttributes Array of strings that contains searchable attributes sorted by order of importance(most to least important)\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateSearchableAttributes = function (searchableAttributes) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, searchableAttributes)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the searchable-attributes.\r\n           * @memberof Index\r\n           * @method resetSearchableAttributes\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetSearchableAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// DISPLAYED ATTRIBUTE\n          ///\n\n          /**\r\n           * Get the displayed-attributes\r\n           * @memberof Index\r\n           * @method getDisplayedAttributes\r\n           * @returns {Promise<string[]>} Promise containing array of displayed-attributes\r\n           */\n\n          Index.prototype.getDisplayedAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the displayed-attributes.\r\n           * @memberof Index\r\n           * @method updateDisplayedAttributes\r\n           * @param {DisplayedAttributes} displayedAttributes Array of strings that contains attributes of an index to display\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateDisplayedAttributes = function (displayedAttributes) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest.put(url, displayedAttributes)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the displayed-attributes.\r\n           * @memberof Index\r\n           * @method resetDisplayedAttributes\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetDisplayedAttributes = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// TYPO TOLERANCE\n          ///\n\n          /**\r\n           * Get the typo tolerance settings.\r\n           * @memberof Index\r\n           * @method getTypoTolerance\r\n           * @returns {Promise<string[]>} Promise containing the typo tolerance settings.\r\n           */\n\n          Index.prototype.getTypoTolerance = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the typo tolerance settings.\r\n           * @memberof Index\r\n           * @method updateTypoTolerance\r\n           * @param {TypoTolerance} typoTolerance Object containing the custom typo tolerance settings.\r\n           * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n           */\n\n          Index.prototype.updateTypoTolerance = function (typoTolerance) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\n                    return [4\n                    /*yield*/, this.httpRequest.patch(url, typoTolerance)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the typo tolerance settings.\r\n           * @memberof Index\r\n           * @method resetTypoTolerance\r\n           * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n           */\n\n          Index.prototype.resetTypoTolerance = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    task.enqueuedAt = new Date(task.enqueuedAt);\n                    return [2\n                    /*return*/, task];\n                }\n              });\n            });\n          }; ///\n          /// FACETING\n          ///\n\n          /**\r\n           * Get the faceting settings.\r\n           * @memberof Index\r\n           * @method getFaceting\r\n           * @returns {Promise<Faceting>} Promise containing object of faceting index settings\r\n           */\n\n          Index.prototype.getFaceting = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/faceting\");\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update the faceting settings.\r\n           * @memberof Index\r\n           * @method updateFaceting\r\n           * @param {Faceting} faceting Faceting index settings object\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.updateFaceting = function (faceting) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/faceting\");\n                    return [4\n                    /*yield*/, this.httpRequest.patch(url, faceting)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          /**\r\n           * Reset the faceting settings.\r\n           * @memberof Index\r\n           * @method resetFaceting\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Index.prototype.resetFaceting = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes/\".concat(this.uid, \"/settings/faceting\");\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          };\n          return Index;\n        }();\n\n        /*\r\n         * Bundle: MeiliSearch\r\n         * Project: MeiliSearch - Javascript API\r\n         * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n         * Copyright: 2019, MeiliSearch\r\n         */\n\n        var Client = /** @class */\n        function () {\n          /**\r\n           * Creates new MeiliSearch instance\r\n           * @param {Config} config Configuration object\r\n           */\n          function Client(config) {\n            this.config = config;\n            this.httpRequest = new HttpRequests(config);\n            this.tasks = new TaskClient(config);\n          }\n          /**\r\n           * Return an Index instance\r\n           * @memberof MeiliSearch\r\n           * @method index\r\n           * @template T\r\n           * @param {string} indexUid The index UID\r\n           * @returns {Index<T>} Instance of Index\r\n           */\n\n          Client.prototype.index = function (indexUid) {\n            return new Index(this.config, indexUid);\n          };\n          /**\r\n           * Gather information about an index by calling MeiliSearch and\r\n           * return an Index instance with the gathered information\r\n           * @memberof MeiliSearch\r\n           * @method getIndex\r\n           * @template T\r\n           * @param {string} indexUid The index UID\r\n           * @returns {Promise<Index<T>>} Promise returning Index instance\r\n           */\n\n          Client.prototype.getIndex = function (indexUid) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                return [2\n                /*return*/, new Index(this.config, indexUid).fetchInfo()];\n              });\n            });\n          };\n          /**\r\n           * Gather information about an index by calling MeiliSearch and\r\n           * return the raw JSON response\r\n           * @memberof MeiliSearch\r\n           * @method getRawIndex\r\n           * @param {string} indexUid The index UID\r\n           * @returns {Promise<IndexObject>} Promise returning index information\r\n           */\n\n          Client.prototype.getRawIndex = function (indexUid) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                return [2\n                /*return*/, new Index(this.config, indexUid).getRawInfo()];\n              });\n            });\n          };\n          /**\r\n           * Get all the indexes as Index instances.\r\n           * @memberof MeiliSearch\r\n           * @method getIndexes\r\n           * @param {IndexesQuery} [parameters={}] - Parameters to browse the indexes\r\n           *\r\n           * @returns {Promise<IndexesResults<Index[]>>} Promise returning array of raw index information\r\n           */\n\n          Client.prototype.getIndexes = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var rawIndexes, indexes;\n              var _this = this;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.getRawIndexes(parameters)];\n                  case 1:\n                    rawIndexes = _a.sent();\n                    indexes = rawIndexes.results.map(function (index) {\n                      return new Index(_this.config, index.uid, index.primaryKey);\n                    });\n                    return [2\n                    /*return*/, __assign(__assign({}, rawIndexes), {\n                      results: indexes\n                    })];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get all the indexes in their raw value (no Index instances).\r\n           * @memberof MeiliSearch\r\n           * @method getRawIndexes\r\n           * @param {IndexesQuery} [parameters={}] - Parameters to browse the indexes\r\n           *\r\n           * @returns {Promise<IndexesResults<IndexObject[]>>} Promise returning array of raw index information\r\n           */\n\n          Client.prototype.getRawIndexes = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"indexes\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url, parameters)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Create a new index\r\n           * @memberof MeiliSearch\r\n           * @method createIndex\r\n           * @template T\r\n           * @param {string} uid The index UID\r\n           * @param {IndexOptions} options Index options\r\n           * @returns {Promise<Index<T>>} Promise returning Index instance\r\n           */\n\n          Client.prototype.createIndex = function (uid, options) {\n            if (options === void 0) {\n              options = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, Index.create(uid, options, this.config)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update an index\r\n           * @memberof MeiliSearch\r\n           * @method updateIndex\r\n           * @template T\r\n           * @param {string} uid The index UID\r\n           * @param {IndexOptions} options Index options to update\r\n           * @returns {Promise<Index<T>>} Promise returning Index instance after updating\r\n           */\n\n          Client.prototype.updateIndex = function (uid, options) {\n            if (options === void 0) {\n              options = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, new Index(this.config, uid).update(options)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete an index\r\n           * @memberof MeiliSearch\r\n           * @method deleteIndex\r\n           * @param {string} uid The index UID\r\n           * @returns {Promise<void>} Promise which resolves when index is deleted successfully\r\n           */\n\n          Client.prototype.deleteIndex = function (uid) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, new Index(this.config, uid)[\"delete\"]()];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Deletes an index if it already exists.\r\n           * @memberof MeiliSearch\r\n           * @method deleteIndexIfExists\r\n           * @param {string} uid The index UID\r\n           * @returns {Promise<boolean>} Promise which resolves to true when index exists and is deleted successfully, otherwise false if it does not exist\r\n           */\n\n          Client.prototype.deleteIndexIfExists = function (uid) {\n            return __awaiter(this, void 0, void 0, function () {\n              var e_1;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    _a.trys.push([0, 2,, 3]);\n                    return [4\n                    /*yield*/, this.deleteIndex(uid)];\n                  case 1:\n                    _a.sent();\n                    return [2\n                    /*return*/, true];\n                  case 2:\n                    e_1 = _a.sent();\n                    if (e_1.code === \"index_not_found\"\n                    /* INDEX_NOT_FOUND */) {\n                      return [2\n                      /*return*/, false];\n                    }\n                    throw e_1;\n                  case 3:\n                    return [2\n                    /*return*/];\n                }\n              });\n            });\n          };\n          /**\r\n           * Swaps a list of index tuples.\r\n           *\r\n           * @memberof MeiliSearch\r\n           * @method swapIndexes\r\n           * @param {SwapIndexesParams} params - List of indexes tuples to swap.\r\n           * @returns {Promise<EnqueuedTask>} - Promise returning object of the enqueued task\r\n           */\n\n          Client.prototype.swapIndexes = function (params) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = '/swap-indexes';\n                    return [4\n                    /*yield*/, this.httpRequest.post(url, params)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          }; ///\n          /// TASKS\n          ///\n\n          /**\r\n           * Get the list of all client tasks\r\n           * @memberof MeiliSearch\r\n           * @method getTasks\r\n           * @param {TasksQuery} [parameters={}] - Parameters to browse the tasks\r\n           *\r\n           * @returns {Promise<TasksResults>} - Promise returning all tasks\r\n           */\n\n          Client.prototype.getTasks = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.getTasks(parameters)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get one task on the client scope\r\n           * @memberof MeiliSearch\r\n           * @method getTask\r\n           * @param {number} taskUid - Task identifier\r\n           * @returns {Promise<Task>} - Promise returning a task\r\n           */\n\n          Client.prototype.getTask = function (taskUid) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.getTask(taskUid)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Wait for multiple tasks to be finished.\r\n           *\r\n           * @memberof MeiliSearch\r\n           * @method waitForTasks\r\n           * @param {number[]} taskUids - Tasks identifier\r\n           * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n           *\r\n           * @returns {Promise<Task[]>} - Promise returning an array of tasks\r\n           */\n\n          Client.prototype.waitForTasks = function (taskUids, _a) {\n            var _b = _a === void 0 ? {} : _a,\n              _c = _b.timeOutMs,\n              timeOutMs = _c === void 0 ? 5000 : _c,\n              _d = _b.intervalMs,\n              intervalMs = _d === void 0 ? 50 : _d;\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.waitForTasks(taskUids, {\n                      timeOutMs: timeOutMs,\n                      intervalMs: intervalMs\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _e.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Wait for a task to be finished.\r\n           *\r\n           * @memberof MeiliSearch\r\n           * @method waitForTask\r\n           *\r\n           * @param {number} taskUid - Task identifier\r\n           * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n           *\r\n           * @returns {Promise<Task>} - Promise returning an array of tasks\r\n           */\n\n          Client.prototype.waitForTask = function (taskUid, _a) {\n            var _b = _a === void 0 ? {} : _a,\n              _c = _b.timeOutMs,\n              timeOutMs = _c === void 0 ? 5000 : _c,\n              _d = _b.intervalMs,\n              intervalMs = _d === void 0 ? 50 : _d;\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.waitForTask(taskUid, {\n                      timeOutMs: timeOutMs,\n                      intervalMs: intervalMs\n                    })];\n                  case 1:\n                    return [2\n                    /*return*/, _e.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Cancel a list of enqueued or processing tasks.\r\n           * @memberof MeiliSearch\r\n           * @method cancelTasks\r\n           * @param {CancelTasksQuery} [parameters={}] - Parameters to filter the tasks.\r\n           *\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Client.prototype.cancelTasks = function (parameters) {\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.cancelTasks(parameters)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete a list of tasks.\r\n           * @memberof MeiliSearch\r\n           * @method deleteTasks\r\n           * @param {DeleteTasksQuery} [parameters={}] - Parameters to filter the tasks.\r\n           *\r\n           * @returns {Promise<EnqueuedTask>} Promise containing an EnqueuedTask\r\n           */\n\n          Client.prototype.deleteTasks = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/, this.tasks.deleteTasks(parameters)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          }; ///\n          /// KEYS\n          ///\n\n          /**\r\n           * Get all API keys\r\n           * @memberof MeiliSearch\r\n           * @method getKeys\r\n           * @param {KeysQuery} [parameters={}] - Parameters to browse the indexes\r\n           *\r\n           * @returns {Promise<KeysResults>} Promise returning an object with keys\r\n           */\n\n          Client.prototype.getKeys = function (parameters) {\n            if (parameters === void 0) {\n              parameters = {};\n            }\n            return __awaiter(this, void 0, void 0, function () {\n              var url, keys;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"keys\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url, parameters)];\n                  case 1:\n                    keys = _a.sent();\n                    keys.results = keys.results.map(function (key) {\n                      return __assign(__assign({}, key), {\n                        createdAt: new Date(key.createdAt),\n                        updateAt: new Date(key.updateAt)\n                      });\n                    });\n                    return [2\n                    /*return*/, keys];\n                }\n              });\n            });\n          };\n          /**\r\n           * Get one API key\r\n           * @memberof MeiliSearch\r\n           * @method getKey\r\n           *\r\n           * @param {string} keyOrUid - Key or uid of the API key\r\n           * @returns {Promise<Key>} Promise returning a key\r\n           */\n\n          Client.prototype.getKey = function (keyOrUid) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"keys/\".concat(keyOrUid);\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Create one API key\r\n           * @memberof MeiliSearch\r\n           * @method createKey\r\n           *\r\n           * @param {KeyCreation} options - Key options\r\n           * @returns {Promise<Key>} Promise returning a key\r\n           */\n\n          Client.prototype.createKey = function (options) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"keys\";\n                    return [4\n                    /*yield*/, this.httpRequest.post(url, options)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Update one API key\r\n           * @memberof MeiliSearch\r\n           * @method updateKey\r\n           *\r\n           * @param {string} keyOrUid - Key\r\n           * @param {KeyUpdate} options - Key options\r\n           * @returns {Promise<Key>} Promise returning a key\r\n           */\n\n          Client.prototype.updateKey = function (keyOrUid, options) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"keys/\".concat(keyOrUid);\n                    return [4\n                    /*yield*/, this.httpRequest.patch(url, options)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Delete one API key\r\n           * @memberof MeiliSearch\r\n           * @method deleteKey\r\n           *\r\n           * @param {string} keyOrUid - Key\r\n           * @returns {Promise<Void>}\r\n           */\n\n          Client.prototype.deleteKey = function (keyOrUid) {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"keys/\".concat(keyOrUid);\n                    return [4\n                    /*yield*/, this.httpRequest[\"delete\"](url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          }; ///\n          /// HEALTH\n          ///\n\n          /**\r\n           * Checks if the server is healthy, otherwise an error will be thrown.\r\n           * @memberof MeiliSearch\r\n           * @method health\r\n           * @returns {Promise<Health>} Promise returning an object with health details\r\n           */\n\n          Client.prototype.health = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"health\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          };\n          /**\r\n           * Checks if the server is healthy, return true or false.\r\n           * @memberof MeiliSearch\r\n           * @method isHealthy\r\n           * @returns {Promise<boolean>} Promise returning a boolean\r\n           */\n\n          Client.prototype.isHealthy = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    _a.trys.push([0, 2,, 3]);\n                    url = \"health\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    _a.sent();\n                    return [2\n                    /*return*/, true];\n                  case 2:\n                    _a.sent();\n                    return [2\n                    /*return*/, false];\n                  case 3:\n                    return [2\n                    /*return*/];\n                }\n              });\n            });\n          }; ///\n          /// STATS\n          ///\n\n          /**\r\n           * Get the stats of all the database\r\n           * @memberof MeiliSearch\r\n           * @method getStats\r\n           * @returns {Promise<Stats>} Promise returning object of all the stats\r\n           */\n\n          Client.prototype.getStats = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"stats\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          }; ///\n          /// VERSION\n          ///\n\n          /**\r\n           * Get the version of MeiliSearch\r\n           * @memberof MeiliSearch\r\n           * @method getVersion\r\n           * @returns {Promise<Version>} Promise returning object with version details\r\n           */\n\n          Client.prototype.getVersion = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"version\";\n                    return [4\n                    /*yield*/, this.httpRequest.get(url)];\n                  case 1:\n                    return [2\n                    /*return*/, _a.sent()];\n                }\n              });\n            });\n          }; ///\n          /// DUMPS\n          ///\n\n          /**\r\n           * Creates a dump\r\n           * @memberof MeiliSearch\r\n           * @method createDump\r\n           * @returns {Promise<EnqueuedTask>} Promise returning object of the enqueued task\r\n           */\n\n          Client.prototype.createDump = function () {\n            return __awaiter(this, void 0, void 0, function () {\n              var url, task;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    url = \"dumps\";\n                    return [4\n                    /*yield*/, this.httpRequest.post(url)];\n                  case 1:\n                    task = _a.sent();\n                    return [2\n                    /*return*/, new EnqueuedTask(task)];\n                }\n              });\n            });\n          }; ///\n          /// TOKENS\n          ///\n\n          /**\r\n           * Generate a tenant token\r\n           *\r\n           * @memberof MeiliSearch\r\n           * @method generateTenantToken\r\n           * @param {apiKeyUid} apiKeyUid The uid of the api key used as issuer of the token.\r\n           * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n           * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n           *\r\n           * @returns {String} The token in JWT format.\r\n           */\n\n          Client.prototype.generateTenantToken = function (_apiKeyUid, _searchRules, _options) {\n            var error = new Error();\n            throw new Error(\"Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment \\n \".concat(error.stack, \".\"));\n          };\n          return Client;\n        }();\n        var MeiliSearch = /** @class */\n        function (_super) {\n          __extends(MeiliSearch, _super);\n          function MeiliSearch(config) {\n            return _super.call(this, config) || this;\n          }\n          return MeiliSearch;\n        }(Client);\n        exports.Index = Index;\n        exports.MatchingStrategies = MatchingStrategies;\n        exports.MeiliSearch = MeiliSearch;\n        exports.MeiliSearchApiError = MeiliSearchApiError;\n        exports.MeiliSearchCommunicationError = MeiliSearchCommunicationError;\n        exports.MeiliSearchError = MeiliSearchError;\n        exports.MeiliSearchTimeOutError = MeiliSearchTimeOutError;\n        exports[\"default\"] = MeiliSearch;\n        exports.httpErrorHandler = httpErrorHandler;\n        exports.httpResponseErrorHandler = httpResponseErrorHandler;\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n      });\n    });\n\n    var removeUndefined = function (arr) {\r\n        return arr.filter(function (x) { return x !== undefined; });\r\n    };\n\n    /**\r\n     * @param  {any} str\r\n     * @returns {boolean}\r\n     */\r\n    /**\r\n     * @param  {string} filter\r\n     * @returns {string}\r\n     */\r\n    function replaceColonByEqualSign(filter) {\r\n        // will only change first occurence of `:`\r\n        return filter.replace(/:(.*)/i, '=\"$1\"');\r\n    }\r\n    /**\r\n     * @param  {any[]} arr\r\n     * @returns {string}\r\n     */\r\n    function stringifyArray(arr) {\r\n        return arr.reduce(function (acc, curr) {\r\n            return (acc += JSON.stringify(curr));\r\n        }, '');\r\n    }\n\n    function isPureObject(data) {\r\n        return typeof data === 'object' && !Array.isArray(data) && data !== null;\r\n    }\n\n    /**\r\n     * apiKey callback definition\r\n     * @callback apiKeyCallback\r\n     * @returns {string} - The apiKey to use\r\n     */\r\n    /**\r\n     * Validates host and apiKey parameters, throws if invalid\r\n     * @param hostUrl\r\n     * @param apiKey\r\n     */\r\n    function validateInstantMeiliSearchParams(hostUrl, apiKey) {\r\n        // Validate host url\r\n        if (typeof hostUrl !== 'string') {\r\n            throw new TypeError('Provided hostUrl value (1st parameter) is not a string, expected string');\r\n        }\r\n        // Validate api key\r\n        if (typeof apiKey !== 'string' && typeof apiKey !== 'function') {\r\n            throw new TypeError('Provided apiKey value (2nd parameter) is not a string or a function, expected string or function');\r\n        }\r\n    }\n\n    /**\r\n     * @param  {string} filter\r\n     */\r\n    var adaptFilterSyntax = function (filter) {\r\n        var matches = filter.match(/([^=]*)=\"?([^\\\\\"]*)\"?$/);\r\n        if (matches) {\r\n            matches[0]; var filterName = matches[1], value = matches[2];\r\n            return [{ filterName: filterName, value: value }];\r\n        }\r\n        return [];\r\n    };\r\n    /**\r\n     * @param  {Filter} filters?\r\n     * @returns {Array}\r\n     */\r\n    function extractFilters(filters) {\r\n        if (typeof filters === 'string') {\r\n            return adaptFilterSyntax(filters);\r\n        }\r\n        else if (Array.isArray(filters)) {\r\n            return filters\r\n                .map(function (nestedFilter) {\r\n                if (Array.isArray(nestedFilter)) {\r\n                    return nestedFilter.map(function (filter) { return adaptFilterSyntax(filter); });\r\n                }\r\n                return adaptFilterSyntax(nestedFilter);\r\n            })\r\n                .flat(2);\r\n        }\r\n        return [];\r\n    }\r\n    /**\r\n     * @param  {Filter} filters?\r\n     * @returns {FacetsCache}\r\n     */\r\n    function getFacetsFromFilter(filters) {\r\n        var extractedFilters = extractFilters(filters);\r\n        var cleanFilters = removeUndefined(extractedFilters);\r\n        return cleanFilters.reduce(function (cache, parsedFilter) {\r\n            var _a;\r\n            var filterName = parsedFilter.filterName, value = parsedFilter.value;\r\n            var prevFields = cache[filterName] || [];\r\n            cache = __assign(__assign({}, cache), (_a = {}, _a[filterName] = __spreadArray(__spreadArray([], prevFields, true), [value], false), _a));\r\n            return cache;\r\n        }, {});\r\n    }\r\n    function getFacetsFromDefaultDistribution(facetDistribution) {\r\n        return Object.keys(facetDistribution).reduce(function (cache, facet) {\r\n            var _a;\r\n            var facetValues = Object.keys(facetDistribution[facet]);\r\n            return __assign(__assign({}, cache), (_a = {}, _a[facet] = facetValues, _a));\r\n        }, {});\r\n    }\r\n    /**\r\n     * @param  {Filter} filters?\r\n     * @returns {FacetsCache}\r\n     */\r\n    function extractFacets(searchContext, searchParams) {\r\n        if (searchContext.keepZeroFacets) {\r\n            return getFacetsFromDefaultDistribution(searchContext.defaultFacetDistribution);\r\n        }\r\n        else {\r\n            return getFacetsFromFilter(searchParams === null || searchParams === void 0 ? void 0 : searchParams.filter);\r\n        }\r\n    }\r\n    /**\r\n     * Assign missing filters to facetDistribution.\r\n     * All facets passed as filter should appear in the facetDistribution.\r\n     * If not present, the facet is added with 0 as value.\r\n     *\r\n     *\r\n     * @param  {FacetsCache} cache?\r\n     * @param  {FacetDistribution} distribution?\r\n     * @returns {FacetDistribution}\r\n     */\r\n    function addMissingFacets(cachedFacets, distribution) {\r\n        distribution = distribution || {};\r\n        // If cachedFacets contains something\r\n        if (cachedFacets && Object.keys(cachedFacets).length > 0) {\r\n            // for all filters in cached filters\r\n            for (var cachedFacet in cachedFacets) {\r\n                // if facet does not exist on returned distribution, add an empty object\r\n                if (!distribution[cachedFacet])\r\n                    distribution[cachedFacet] = {};\r\n                // for all fields in every filter\r\n                for (var _i = 0, _a = cachedFacets[cachedFacet]; _i < _a.length; _i++) {\r\n                    var cachedField = _a[_i];\r\n                    // if the field is not present in the returned distribution\r\n                    // set it at 0\r\n                    if (!Object.keys(distribution[cachedFacet]).includes(cachedField)) {\r\n                        // add 0 value\r\n                        distribution[cachedFacet][cachedField] = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return distribution;\r\n    }\n\n    /**\r\n     * @param  {ResponseCacher} cache\r\n     */\r\n    function SearchResolver(client, cache) {\r\n        return {\r\n            /**\r\n             * @param  {SearchContext} searchContext\r\n             * @param  {MeiliSearchParams} searchParams\r\n             * @param  {MeiliSearch} client\r\n             * @returns {Promise}\r\n             */\r\n            searchResponse: function (searchContext, searchParams) {\r\n                return __awaiter(this, void 0, void 0, function () {\r\n                    var placeholderSearch, query, key, cachedResponse, cachedFacets, searchResponse;\r\n                    return __generator(this, function (_a) {\r\n                        switch (_a.label) {\r\n                            case 0:\r\n                                placeholderSearch = searchContext.placeholderSearch, query = searchContext.query;\r\n                                key = cache.formatKey([\r\n                                    searchParams,\r\n                                    searchContext.indexUid,\r\n                                    searchContext.query,\r\n                                    searchContext.pagination,\r\n                                ]);\r\n                                cachedResponse = cache.getEntry(key);\r\n                                // Check if specific request is already cached with its associated search response.\r\n                                if (cachedResponse)\r\n                                    return [2 /*return*/, cachedResponse];\r\n                                cachedFacets = extractFacets(searchContext, searchParams);\r\n                                return [4 /*yield*/, client\r\n                                        .index(searchContext.indexUid)\r\n                                        .search(searchContext.query, searchParams)\r\n                                    // Add missing facets back into facetDistribution\r\n                                ];\r\n                            case 1:\r\n                                searchResponse = _a.sent();\r\n                                // Add missing facets back into facetDistribution\r\n                                searchResponse.facetDistribution = addMissingFacets(cachedFacets, searchResponse.facetDistribution);\r\n                                // query can be: empty string, undefined or null\r\n                                // all of them are falsy's\r\n                                if (!placeholderSearch && !query) {\r\n                                    searchResponse.hits = [];\r\n                                }\r\n                                // Cache response\r\n                                cache.setEntry(key, searchResponse);\r\n                                return [2 /*return*/, searchResponse];\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        };\r\n    }\n\n    /**\r\n     * @param  {number} rad\r\n     * @returns {number}\r\n     */\r\n    function rad2degr(rad) {\r\n        return (rad * 180) / Math.PI;\r\n    }\r\n    /**\r\n     * @param  {number} degr\r\n     * @returns {number}\r\n     */\r\n    function degr2rad(degr) {\r\n        return (degr * Math.PI) / 180;\r\n    }\r\n    /**\r\n     * @param  {number} lat1\r\n     * @param  {number} lng1\r\n     * @param  {number} lat2\r\n     * @param  {number} lng2\r\n     * @returns {string}\r\n     */\r\n    function middleGeoPoints(lat1, lng1, lat2, lng2) {\r\n        // convert to radians\r\n        lat1 = degr2rad(lat1);\r\n        lng1 = degr2rad(lng1);\r\n        var x1 = Math.cos(lat1) * Math.cos(lng1);\r\n        var y1 = Math.cos(lat1) * Math.sin(lng1);\r\n        var z1 = Math.sin(lat1);\r\n        // convert to radians\r\n        lat2 = degr2rad(lat2);\r\n        lng2 = degr2rad(lng2);\r\n        var x2 = Math.cos(lat2) * Math.cos(lng2);\r\n        var y2 = Math.cos(lat2) * Math.sin(lng2);\r\n        var z2 = Math.sin(lat2);\r\n        var x = x1 + x2;\r\n        var y = y1 + y2;\r\n        var z = z1 + z2;\r\n        var Hyp = Math.sqrt(x * x + y * y);\r\n        var lng3 = Math.atan2(y, x);\r\n        var lat3 = Math.atan2(z, Hyp);\r\n        if (lng1 < lng2 || (lng1 > lng2 && lng1 > Math.PI && lng2 < -Math.PI)) {\r\n            lat3 = lat3 + Math.PI;\r\n            lng3 = lng3 + Math.PI;\r\n        }\r\n        else {\r\n            lat3 = rad2degr(lat3);\r\n            lng3 = rad2degr(lng3);\r\n        }\r\n        if (Math.abs(x) < Math.pow(10, -9) &&\r\n            Math.abs(y) < Math.pow(10, -9) &&\r\n            Math.abs(z) < Math.pow(10, -9)) {\r\n            lat3 = 0;\r\n            lng3 = 0;\r\n        }\r\n        return \"\".concat(lat3, \",\").concat(lng3);\r\n    }\r\n    /**\r\n     * @param  {number} lat1\r\n     * @param  {number} lng1\r\n     * @param  {number} lat2\r\n     * @param  {number} lng2\r\n     * @returns {number}\r\n     */\r\n    function getDistanceInMeter(lat1, lng1, lat2, lng2) {\r\n        // Haversine Algorithm\r\n        var R = 6371e3; // metres\r\n        var latRad1 = (lat1 * Math.PI) / 180;\r\n        var latRad2 = (lat2 * Math.PI) / 180;\r\n        var latCenterRad = ((lat2 - lat1) * Math.PI) / 180;\r\n        var lngCenterRad = ((lng2 - lng1) * Math.PI) / 180;\r\n        var a = Math.sin(latCenterRad / 2) * Math.sin(latCenterRad / 2) +\r\n            Math.cos(latRad1) *\r\n                Math.cos(latRad2) *\r\n                Math.sin(lngCenterRad / 2) *\r\n                Math.sin(lngCenterRad / 2);\r\n        var bearing = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n        var distance = R * bearing; // in metres\r\n        return distance;\r\n    }\n\n    function adaptGeoPointsRules(geoSearchContext) {\r\n        if (!geoSearchContext) {\r\n            return undefined;\r\n        }\r\n        var insideBoundingBox = geoSearchContext.insideBoundingBox, aroundLatLng = geoSearchContext.aroundLatLng, aroundRadius = geoSearchContext.aroundRadius, minimumAroundRadius = geoSearchContext.minimumAroundRadius;\r\n        var middlePoint;\r\n        var radius;\r\n        if (aroundLatLng) {\r\n            middlePoint = aroundLatLng;\r\n        }\r\n        if (aroundRadius != null || minimumAroundRadius != null) {\r\n            if (aroundRadius != null)\r\n                radius = aroundRadius;\r\n            else\r\n                radius = minimumAroundRadius;\r\n        }\r\n        // If insideBoundingBox is provided it takes precedent over all other options\r\n        if (insideBoundingBox && typeof insideBoundingBox === 'string') {\r\n            var _a = insideBoundingBox.split(','), lat1Raw = _a[0], lng1Raw = _a[1], lat2Raw = _a[2], lng2Raw = _a[3];\r\n            var _b = [\r\n                parseFloat(lat1Raw),\r\n                parseFloat(lng1Raw),\r\n                parseFloat(lat2Raw),\r\n                parseFloat(lng2Raw),\r\n            ], lat1 = _b[0], lng1 = _b[1], lat2 = _b[2], lng2 = _b[3];\r\n            radius = getDistanceInMeter(lat1, lng1, lat2, lng2) / 2;\r\n            middlePoint = middleGeoPoints(lat1, lng1, lat2, lng2);\r\n        }\r\n        if (middlePoint != null && radius != null) {\r\n            var _c = middlePoint.split(','), lat3 = _c[0], lng3 = _c[1];\r\n            lat3 = Number.parseFloat(lat3).toFixed(5);\r\n            lng3 = Number.parseFloat(lng3).toFixed(5);\r\n            var filter = \"_geoRadius(\".concat(lat3, \", \").concat(lng3, \", \").concat(radius, \")\");\r\n            return { filter: filter };\r\n        }\r\n        return undefined;\r\n    }\r\n    function createGeoSearchContext(searchContext) {\r\n        var geoContext = {};\r\n        var aroundLatLng = searchContext.aroundLatLng, aroundLatLngViaIP = searchContext.aroundLatLngViaIP, aroundRadius = searchContext.aroundRadius, aroundPrecision = searchContext.aroundPrecision, minimumAroundRadius = searchContext.minimumAroundRadius, insideBoundingBox = searchContext.insideBoundingBox, insidePolygon = searchContext.insidePolygon;\r\n        if (aroundLatLng) {\r\n            geoContext.aroundLatLng = aroundLatLng;\r\n        }\r\n        if (aroundLatLngViaIP) {\r\n            console.warn('instant-meilisearch: `aroundLatLngViaIP` is not supported.');\r\n        }\r\n        if (aroundRadius) {\r\n            geoContext.aroundRadius = aroundRadius;\r\n        }\r\n        if (aroundPrecision) {\r\n            console.warn(\"instant-meilisearch: `aroundPrecision` is not supported.\\n    See this discussion to track its implementation https://github.com/meilisearch/product/discussions/264\");\r\n        }\r\n        if (minimumAroundRadius) {\r\n            geoContext.minimumAroundRadius = minimumAroundRadius;\r\n        }\r\n        if (insideBoundingBox) {\r\n            geoContext.insideBoundingBox = insideBoundingBox;\r\n        }\r\n        // See related issue: https://github.com/meilisearch/instant-meilisearch/issues/555\r\n        if (insidePolygon) {\r\n            console.warn(\"instant-meilisearch: `insidePolygon` is not implented in instant-meilisearch.\");\r\n        }\r\n        return geoContext;\r\n    }\n\n    /**\r\n     * Transform InstantSearch filter to Meilisearch filter.\r\n     * Change sign from `:` to `=` in nested filter object.\r\n     * example: [`genres:comedy`] becomes [`genres=comedy`]\r\n     *\r\n     * @param  {SearchContext['facetFilters']} filters?\r\n     * @returns {Filter}\r\n     */\r\n    function transformFilter(filters) {\r\n        if (typeof filters === 'string') {\r\n            return replaceColonByEqualSign(filters);\r\n        }\r\n        else if (Array.isArray(filters))\r\n            return filters\r\n                .map(function (filter) {\r\n                if (Array.isArray(filter))\r\n                    return filter\r\n                        .map(function (nestedFilter) { return replaceColonByEqualSign(nestedFilter); })\r\n                        .filter(function (elem) { return elem; });\r\n                else {\r\n                    return replaceColonByEqualSign(filter);\r\n                }\r\n            })\r\n                .filter(function (elem) { return elem; });\r\n        return [];\r\n    }\r\n    /**\r\n     * Return the filter in an array if it is a string\r\n     * If filter is array, return without change.\r\n     *\r\n     * @param  {Filter} filter\r\n     * @returns {Array}\r\n     */\r\n    function filterToArray(filter) {\r\n        // Filter is a string\r\n        if (filter === '')\r\n            return [];\r\n        else if (typeof filter === 'string')\r\n            return [filter];\r\n        // Filter is either an array of strings, or an array of array of strings\r\n        return filter;\r\n    }\r\n    /**\r\n     * Merge facetFilters, numericFilters and filters together.\r\n     *\r\n     * @param  {Filter} facetFilters\r\n     * @param  {Filter} numericFilters\r\n     * @param  {string} filters\r\n     * @returns {Filter}\r\n     */\r\n    function mergeFilters(facetFilters, numericFilters, filters) {\r\n        var adaptedFilters = filters.trim();\r\n        var adaptedFacetFilters = filterToArray(facetFilters);\r\n        var adaptedNumericFilters = filterToArray(numericFilters);\r\n        var adaptedFilter = __spreadArray(__spreadArray(__spreadArray([], adaptedFacetFilters, true), adaptedNumericFilters, true), [\r\n            adaptedFilters,\r\n        ], false);\r\n        var cleanedFilters = adaptedFilter.filter(function (filter) {\r\n            if (Array.isArray(filter)) {\r\n                return filter.length;\r\n            }\r\n            return filter;\r\n        });\r\n        return cleanedFilters;\r\n    }\r\n    /**\r\n     * Adapt instantsearch.js filters to Meilisearch filters by\r\n     * combining and transforming all provided filters.\r\n     *\r\n     * @param  {string|undefined} filters\r\n     * @param  {SearchContext['numericFilters']} numericFilters\r\n     * @param  {SearchContext['facetFilters']} facetFilters\r\n     * @returns {Filter}\r\n     */\r\n    function adaptFilters(filters, numericFilters, facetFilters) {\r\n        var transformedFilter = transformFilter(facetFilters || []);\r\n        var transformedNumericFilter = transformFilter(numericFilters || []);\r\n        return mergeFilters(transformedFilter, transformedNumericFilter, filters || '');\r\n    }\n\n    function setScrollPagination(hitsPerPage, page, query, placeholderSearch) {\r\n        if (!placeholderSearch && query === '') {\r\n            return {\r\n                limit: 0,\r\n                offset: 0\r\n            };\r\n        }\r\n        return {\r\n            limit: hitsPerPage + 1,\r\n            offset: page * hitsPerPage\r\n        };\r\n    }\r\n    function setFinitePagination(hitsPerPage, page, query, placeholderSearch) {\r\n        if (!placeholderSearch && query === '') {\r\n            return {\r\n                hitsPerPage: 0,\r\n                page: page + 1\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                hitsPerPage: hitsPerPage,\r\n                page: page + 1\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Adapts instantsearch.js and instant-meilisearch options\r\n     * to meilisearch search query parameters.\r\n     *\r\n     * @param  {SearchContext} searchContext\r\n     *\r\n     * @returns {MeiliSearchParams}\r\n     */\r\n    function MeiliParamsCreator(searchContext) {\r\n        var meiliSearchParams = {};\r\n        var facets = searchContext.facets, attributesToSnippet = searchContext.attributesToSnippet, snippetEllipsisText = searchContext.snippetEllipsisText, attributesToRetrieve = searchContext.attributesToRetrieve, filters = searchContext.filters, numericFilters = searchContext.numericFilters, facetFilters = searchContext.facetFilters, attributesToHighlight = searchContext.attributesToHighlight, highlightPreTag = searchContext.highlightPreTag, highlightPostTag = searchContext.highlightPostTag, placeholderSearch = searchContext.placeholderSearch, query = searchContext.query, sort = searchContext.sort, pagination = searchContext.pagination, matchingStrategy = searchContext.matchingStrategy;\r\n        return {\r\n            getParams: function () {\r\n                return meiliSearchParams;\r\n            },\r\n            addFacets: function () {\r\n                if (facets === null || facets === void 0 ? void 0 : facets.length) {\r\n                    meiliSearchParams.facets = facets;\r\n                }\r\n            },\r\n            addAttributesToCrop: function () {\r\n                if (attributesToSnippet) {\r\n                    meiliSearchParams.attributesToCrop = attributesToSnippet;\r\n                }\r\n            },\r\n            addCropMarker: function () {\r\n                // Attributes To Crop marker\r\n                if (snippetEllipsisText != null) {\r\n                    meiliSearchParams.cropMarker = snippetEllipsisText;\r\n                }\r\n            },\r\n            addAttributesToRetrieve: function () {\r\n                if (attributesToRetrieve) {\r\n                    meiliSearchParams.attributesToRetrieve = attributesToRetrieve;\r\n                }\r\n            },\r\n            addFilters: function () {\r\n                var filter = adaptFilters(filters, numericFilters, facetFilters);\r\n                if (filter.length) {\r\n                    meiliSearchParams.filter = filter;\r\n                }\r\n            },\r\n            addAttributesToHighlight: function () {\r\n                meiliSearchParams.attributesToHighlight = attributesToHighlight || ['*'];\r\n            },\r\n            addPreTag: function () {\r\n                if (highlightPreTag) {\r\n                    meiliSearchParams.highlightPreTag = highlightPreTag;\r\n                }\r\n                else {\r\n                    meiliSearchParams.highlightPreTag = '__ais-highlight__';\r\n                }\r\n            },\r\n            addPostTag: function () {\r\n                if (highlightPostTag) {\r\n                    meiliSearchParams.highlightPostTag = highlightPostTag;\r\n                }\r\n                else {\r\n                    meiliSearchParams.highlightPostTag = '__/ais-highlight__';\r\n                }\r\n            },\r\n            addPagination: function () {\r\n                if (pagination.finite) {\r\n                    var _a = setFinitePagination(pagination.hitsPerPage, pagination.page, query, placeholderSearch), hitsPerPage = _a.hitsPerPage, page = _a.page;\r\n                    meiliSearchParams.hitsPerPage = hitsPerPage;\r\n                    meiliSearchParams.page = page;\r\n                }\r\n                else {\r\n                    var _b = setScrollPagination(pagination.hitsPerPage, pagination.page, query, placeholderSearch), limit = _b.limit, offset = _b.offset;\r\n                    meiliSearchParams.limit = limit;\r\n                    meiliSearchParams.offset = offset;\r\n                }\r\n            },\r\n            addSort: function () {\r\n                if (sort === null || sort === void 0 ? void 0 : sort.length) {\r\n                    meiliSearchParams.sort = [sort];\r\n                }\r\n            },\r\n            addGeoSearchRules: function () {\r\n                var geoSearchContext = createGeoSearchContext(searchContext);\r\n                var geoRules = adaptGeoPointsRules(geoSearchContext);\r\n                if (geoRules === null || geoRules === void 0 ? void 0 : geoRules.filter) {\r\n                    if (meiliSearchParams.filter) {\r\n                        meiliSearchParams.filter.unshift(geoRules.filter);\r\n                    }\r\n                    else {\r\n                        meiliSearchParams.filter = [geoRules.filter];\r\n                    }\r\n                }\r\n            },\r\n            addMatchingStrategy: function () {\r\n                if (matchingStrategy) {\r\n                    meiliSearchParams.matchingStrategy = matchingStrategy;\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Adapt search request from instantsearch.js\r\n     * to search request compliant with Meilisearch\r\n     *\r\n     * @param  {SearchContext} searchContext\r\n     * @returns {MeiliSearchParams}\r\n     */\r\n    function adaptSearchParams(searchContext) {\r\n        var meilisearchParams = MeiliParamsCreator(searchContext);\r\n        meilisearchParams.addFacets();\r\n        meilisearchParams.addAttributesToHighlight();\r\n        meilisearchParams.addPreTag();\r\n        meilisearchParams.addPostTag();\r\n        meilisearchParams.addAttributesToRetrieve();\r\n        meilisearchParams.addAttributesToCrop();\r\n        meilisearchParams.addCropMarker();\r\n        meilisearchParams.addPagination();\r\n        meilisearchParams.addFilters();\r\n        meilisearchParams.addSort();\r\n        meilisearchParams.addGeoSearchRules();\r\n        meilisearchParams.addMatchingStrategy();\r\n        return meilisearchParams.getParams();\r\n    }\n\n    /**\r\n     * Stringify values following instantsearch practices.\r\n     *\r\n     * @param  {any} value - value that needs to be stringified\r\n     */\r\n    function stringifyValue(value) {\r\n        if (typeof value === 'string') {\r\n            // String\r\n            return value;\r\n        }\r\n        else if (value === undefined) {\r\n            // undefined\r\n            return JSON.stringify(null);\r\n        }\r\n        else {\r\n            return JSON.stringify(value);\r\n        }\r\n    }\r\n    /**\r\n     * Recursif function wrap the deepest possible value\r\n     * the following way: { value: \"xx\" }.\r\n     *\r\n     * For example:\r\n     *\r\n     * {\r\n     * \"rootField\": { \"value\": \"x\" }\r\n     * \"nestedField\": { child: { value: \"y\" } }\r\n     * }\r\n     *\r\n     * recursivity continues until the value is not an array or an object.\r\n     *\r\n     * @param  {any} value - value of a field\r\n     *\r\n     * @returns Record<string, any>\r\n     */\r\n    function wrapValue(value) {\r\n        if (Array.isArray(value)) {\r\n            // Array\r\n            return value.map(function (elem) { return wrapValue(elem); });\r\n        }\r\n        else if (isPureObject(value)) {\r\n            // Object\r\n            return Object.keys(value).reduce(function (nested, key) {\r\n                nested[key] = wrapValue(value[key]);\r\n                return nested;\r\n            }, {});\r\n        }\r\n        else {\r\n            return { value: stringifyValue(value) };\r\n        }\r\n    }\r\n    /**\r\n     * Adapt Meilisearch formatted fields to a format compliant to instantsearch.js.\r\n     *\r\n     * @param  {Record<string} formattedHit\r\n     * @param  {SearchContext} searchContext\r\n     * @returns {Record}\r\n     */\r\n    function adaptFormattedFields(hit) {\r\n        if (!hit)\r\n            return {};\r\n        var _formattedResult = wrapValue(hit);\r\n        var highlightedHit = {\r\n            // We could not determine what the differences are between those two fields.\r\n            _highlightResult: _formattedResult,\r\n            _snippetResult: _formattedResult\r\n        };\r\n        return highlightedHit;\r\n    }\n\n    /**\r\n     * @param  {any[]} hits\r\n     * @returns {Array<Record<string, any>>}\r\n     */\r\n    function adaptGeoResponse(hits) {\r\n        var _a;\r\n        for (var i = 0; i < hits.length; i++) {\r\n            var objectID = \"\".concat(i + Math.random() * 1000000);\r\n            if (hits[i]._geo) {\r\n                hits[i]._geoloc = hits[i]._geo;\r\n                hits[i].objectID = objectID;\r\n            }\r\n            if ((_a = hits[i]._formatted) === null || _a === void 0 ? void 0 : _a._geo) {\r\n                hits[i]._formatted._geoloc = hits[i]._formatted._geo;\r\n                hits[i]._formatted.objectID = objectID;\r\n            }\r\n        }\r\n        return hits;\r\n    }\n\n    /**\r\n     * @param  {MeiliSearchResponse<Record<string, any>>} searchResponse\r\n     * @param  {SearchContext} searchContext\r\n     * @returns {Array<Record<string, any>>}\r\n     */\r\n    function adaptHits(searchResponse, searchContext) {\r\n        var primaryKey = searchContext.primaryKey;\r\n        var hits = searchResponse.hits;\r\n        var _a = searchContext.pagination, finite = _a.finite, hitsPerPage = _a.hitsPerPage;\r\n        // if the length of the hits is bigger than the hitsPerPage\r\n        // It means that there is still pages to come as we append limit by hitsPerPage + 1\r\n        // In which case we still need to remove the additional hit returned by Meilisearch\r\n        if (!finite && hits.length > hitsPerPage) {\r\n            hits.splice(hits.length - 1, 1);\r\n        }\r\n        var adaptedHits = hits.map(function (hit) {\r\n            // Creates Hit object compliant with InstantSearch\r\n            if (Object.keys(hit).length > 0) {\r\n                var formattedHit = hit._formatted; hit._matchesPosition; var documentFields = __rest(hit, [\"_formatted\", \"_matchesPosition\"]);\r\n                var adaptedHit = Object.assign(documentFields, adaptFormattedFields(formattedHit));\r\n                if (primaryKey) {\r\n                    adaptedHit.objectID = hit[primaryKey];\r\n                }\r\n                return adaptedHit;\r\n            }\r\n            return hit;\r\n        });\r\n        adaptedHits = adaptGeoResponse(adaptedHits);\r\n        return adaptedHits;\r\n    }\n\n    function adaptTotalHits(searchResponse) {\r\n        var _a = searchResponse.hitsPerPage, hitsPerPage = _a === void 0 ? 0 : _a, _b = searchResponse.totalPages, totalPages = _b === void 0 ? 0 : _b, estimatedTotalHits = searchResponse.estimatedTotalHits, totalHits = searchResponse.totalHits;\r\n        if (estimatedTotalHits != null) {\r\n            return estimatedTotalHits;\r\n        }\r\n        else if (totalHits != null) {\r\n            return totalHits;\r\n        }\r\n        // Should not happen but safeguarding just in case\r\n        return hitsPerPage * totalPages;\r\n    }\n\n    function adaptNbPages(searchResponse, hitsPerPage) {\r\n        if (searchResponse.totalPages != null) {\r\n            return searchResponse.totalPages;\r\n        }\r\n        // Avoid dividing by 0\r\n        if (hitsPerPage === 0) {\r\n            return 0;\r\n        }\r\n        var _a = searchResponse.limit, limit = _a === void 0 ? 20 : _a, _b = searchResponse.offset, offset = _b === void 0 ? 0 : _b, hits = searchResponse.hits;\r\n        var additionalPage = hits.length >= limit ? 1 : 0;\r\n        return offset / hitsPerPage + 1 + additionalPage;\r\n    }\r\n    function adaptPaginationParameters(searchResponse, paginationState) {\r\n        var hitsPerPage = paginationState.hitsPerPage, page = paginationState.page;\r\n        var nbPages = adaptNbPages(searchResponse, hitsPerPage);\r\n        return {\r\n            page: page,\r\n            nbPages: nbPages,\r\n            hitsPerPage: hitsPerPage\r\n        };\r\n    }\n\n    /**\r\n     * Adapt search response from Meilisearch\r\n     * to search response compliant with instantsearch.js\r\n     *\r\n     * @param  {MeiliSearchResponse<Record<string>>} searchResponse\r\n     * @param  {SearchContext} searchContext\r\n     * @returns {{ results: Array<AlgoliaSearchResponse<T>> }}\r\n     */\r\n    function adaptSearchResponse(searchResponse, searchContext) {\r\n        var searchResponseOptionals = {};\r\n        var processingTimeMs = searchResponse.processingTimeMs, query = searchResponse.query, facets = searchResponse.facetDistribution;\r\n        var _a = adaptPaginationParameters(searchResponse, searchContext.pagination), hitsPerPage = _a.hitsPerPage, page = _a.page, nbPages = _a.nbPages;\r\n        var hits = adaptHits(searchResponse, searchContext);\r\n        var nbHits = adaptTotalHits(searchResponse);\r\n        // Create response object compliant with InstantSearch\r\n        var adaptedSearchResponse = __assign({ index: searchContext.indexUid, hitsPerPage: hitsPerPage, page: page, facets: facets, nbPages: nbPages, nbHits: nbHits, processingTimeMS: processingTimeMs, query: query, hits: hits, params: '', exhaustiveNbHits: false }, searchResponseOptionals);\r\n        return {\r\n            results: [adaptedSearchResponse]\r\n        };\r\n    }\n\n    /**\r\n     * Create the current state of the pagination\r\n     *\r\n     * @param  {boolean} [finite]\r\n     * @param  {number} [hitsPerPage]\r\n     * @param  {number} [page]\r\n     * @returns {SearchContext}\r\n     */\r\n    function createPaginationState(finite, hitsPerPage, page) {\r\n        return {\r\n            hitsPerPage: hitsPerPage === undefined ? 20 : hitsPerPage,\r\n            page: page || 0,\r\n            finite: !!finite\r\n        };\r\n    }\n\n    /**\r\n     * @param  {AlgoliaMultipleQueriesQuery} searchRequest\r\n     * @param  {Context} options\r\n     * @returns {SearchContext}\r\n     */\r\n    function createSearchContext(searchRequest, options, defaultFacetDistribution) {\r\n        // Split index name and possible sorting rules\r\n        var _a = searchRequest.indexName.split(':'), indexUid = _a[0], sortByArray = _a.slice(1);\r\n        var instantSearchParams = searchRequest.params;\r\n        var paginationState = createPaginationState(options.finitePagination, instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.hitsPerPage, instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.page);\r\n        var searchContext = __assign(__assign(__assign({}, options), instantSearchParams), { sort: sortByArray.join(':') || '', indexUid: indexUid, pagination: paginationState, defaultFacetDistribution: defaultFacetDistribution || {}, placeholderSearch: options.placeholderSearch !== false, keepZeroFacets: !!options.keepZeroFacets });\r\n        return searchContext;\r\n    }\n\n    /**\r\n     * @param  {Record<string} cache\r\n     * @returns {SearchCache}\r\n     */\r\n    function SearchCache(cache) {\r\n        if (cache === void 0) { cache = {}; }\r\n        var searchCache = cache;\r\n        return {\r\n            getEntry: function (key) {\r\n                if (searchCache[key]) {\r\n                    try {\r\n                        return JSON.parse(searchCache[key]);\r\n                    }\r\n                    catch (_) {\r\n                        return searchCache[key];\r\n                    }\r\n                }\r\n                return undefined;\r\n            },\r\n            formatKey: function (components) {\r\n                return stringifyArray(components);\r\n            },\r\n            setEntry: function (key, searchResponse) {\r\n                searchCache[key] = JSON.stringify(searchResponse);\r\n            },\r\n            clearCache: function () {\r\n                searchCache = {};\r\n            }\r\n        };\r\n    }\n\n    function cacheFirstFacetDistribution(searchResolver, searchContext) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var defaultSearchContext, meilisearchParams, searchResponse;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        defaultSearchContext = __assign(__assign({}, searchContext), { \r\n                            // placeholdersearch true to ensure a request is made\r\n                            placeholderSearch: true, \r\n                            // query set to empty to ensure retrieving the default facetdistribution\r\n                            query: '' });\r\n                        meilisearchParams = MeiliParamsCreator(defaultSearchContext);\r\n                        meilisearchParams.addFacets();\r\n                        meilisearchParams.addPagination();\r\n                        return [4 /*yield*/, searchResolver.searchResponse(defaultSearchContext, meilisearchParams.getParams())];\r\n                    case 1:\r\n                        searchResponse = _a.sent();\r\n                        return [2 /*return*/, searchResponse.facetDistribution || {}];\r\n                }\r\n            });\r\n        });\r\n    }\n\n    var PACKAGE_VERSION = '0.10.1';\n\n    var constructClientAgents = function (clientAgents) {\r\n        if (clientAgents === void 0) { clientAgents = []; }\r\n        var instantMeilisearchAgent = \"Meilisearch instant-meilisearch (v\".concat(PACKAGE_VERSION, \")\");\r\n        return clientAgents.concat(instantMeilisearchAgent);\r\n    };\n\n    /**\r\n     * apiKey callback definition\r\n     * @callback apiKeyCallback\r\n     * @returns {string} - The apiKey to use\r\n     */\r\n    /**\r\n     * Instantiate SearchClient required by instantsearch.js.\r\n     * @param  {string} hostUrl\r\n     * @param  {string | apiKeyCallback} apiKey\r\n     * @param  {InstantMeiliSearchOptions={}} meiliSearchOptions\r\n     * @returns {InstantMeiliSearchInstance}\r\n     */\r\n    function instantMeiliSearch(hostUrl, apiKey, instantMeiliSearchOptions) {\r\n        if (apiKey === void 0) { apiKey = ''; }\r\n        if (instantMeiliSearchOptions === void 0) { instantMeiliSearchOptions = {}; }\r\n        // Validate parameters\r\n        validateInstantMeiliSearchParams(hostUrl, apiKey);\r\n        // Resolve possible function to get apiKey\r\n        apiKey = getApiKey(apiKey);\r\n        var clientAgents = constructClientAgents(instantMeiliSearchOptions.clientAgents);\r\n        var meilisearchClient = new meilisearch_umd.MeiliSearch({\r\n            host: hostUrl,\r\n            apiKey: apiKey,\r\n            clientAgents: clientAgents\r\n        });\r\n        var searchCache = SearchCache();\r\n        // create search resolver with included cache\r\n        var searchResolver = SearchResolver(meilisearchClient, searchCache);\r\n        var defaultFacetDistribution;\r\n        return {\r\n            clearCache: function () { return searchCache.clearCache(); },\r\n            /**\r\n             * @param  {readonlyAlgoliaMultipleQueriesQuery[]} instantSearchRequests\r\n             * @returns {Array}\r\n             */\r\n            search: function (instantSearchRequests) {\r\n                return __awaiter(this, void 0, void 0, function () {\r\n                    var searchRequest, searchContext, adaptedSearchRequest, searchResponse, adaptedSearchResponse, e_1;\r\n                    return __generator(this, function (_a) {\r\n                        switch (_a.label) {\r\n                            case 0:\r\n                                _a.trys.push([0, 4, , 5]);\r\n                                searchRequest = instantSearchRequests[0];\r\n                                searchContext = createSearchContext(searchRequest, instantMeiliSearchOptions, defaultFacetDistribution);\r\n                                adaptedSearchRequest = adaptSearchParams(searchContext);\r\n                                if (!(defaultFacetDistribution === undefined)) return [3 /*break*/, 2];\r\n                                return [4 /*yield*/, cacheFirstFacetDistribution(searchResolver, searchContext)];\r\n                            case 1:\r\n                                defaultFacetDistribution = _a.sent();\r\n                                searchContext.defaultFacetDistribution = defaultFacetDistribution;\r\n                                _a.label = 2;\r\n                            case 2: return [4 /*yield*/, searchResolver.searchResponse(searchContext, adaptedSearchRequest)\r\n                                // Adapt the Meilisearch responsne to a compliant instantsearch.js response\r\n                            ];\r\n                            case 3:\r\n                                searchResponse = _a.sent();\r\n                                adaptedSearchResponse = adaptSearchResponse(searchResponse, searchContext);\r\n                                return [2 /*return*/, adaptedSearchResponse];\r\n                            case 4:\r\n                                e_1 = _a.sent();\r\n                                console.error(e_1);\r\n                                throw new Error(e_1);\r\n                            case 5: return [2 /*return*/];\r\n                        }\r\n                    });\r\n                });\r\n            },\r\n            searchForFacetValues: function (_) {\r\n                return __awaiter(this, void 0, void 0, function () {\r\n                    return __generator(this, function (_a) {\r\n                        switch (_a.label) {\r\n                            case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\r\n                                    reject(new Error('SearchForFacetValues is not compatible with Meilisearch'));\r\n                                    resolve([]); // added here to avoid compilation error\r\n                                })];\r\n                            case 1: return [2 /*return*/, _a.sent()];\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Resolves apiKey if it is a function\r\n     * @param  {string | apiKeyCallback} apiKey\r\n     * @returns {string} api key value\r\n     */\r\n    function getApiKey(apiKey) {\r\n        // If apiKey is function, call it to get the apiKey\r\n        if (typeof apiKey === 'function') {\r\n            var apiKeyFnValue = apiKey();\r\n            if (typeof apiKeyFnValue !== 'string') {\r\n                throw new TypeError('Provided apiKey function (2nd parameter) did not return a string, expected string');\r\n            }\r\n            return apiKeyFnValue;\r\n        }\r\n        return apiKey;\r\n    }\n\n    exports.MatchingStrategies = void 0;\r\n    (function (MatchingStrategies) {\r\n        MatchingStrategies[\"ALL\"] = \"all\";\r\n        MatchingStrategies[\"LAST\"] = \"last\";\r\n    })(exports.MatchingStrategies || (exports.MatchingStrategies = {}));\n\n    exports.instantMeiliSearch = instantMeiliSearch;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvZGlzdC9pbnN0YW50LW1laWxpc2VhcmNoLnVtZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUN3SDtBQUM1SCxDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQStELGlCQUFpQjtBQUNoSDtBQUNBLHdDQUF3QyxNQUFNLCtCQUErQixZQUFZO0FBQ3pGLHVDQUF1QyxNQUFNLG1DQUFtQyxZQUFZO0FBQzVGLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUM1RyxxQkFBcUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQzVKLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHVDQUF1QyxTQUFTO0FBQ2hELHVDQUF1QyxXQUFXLFVBQVU7QUFDNUQsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrSEFBa0gsT0FBTztBQUN6SCxxRkFBcUYsaUJBQWlCO0FBQ3RHLDZEQUE2RCxnQkFBZ0IsUUFBUTtBQUNyRixtREFBbUQsZ0JBQWdCLGdCQUFnQjtBQUNuRjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsY0FBYyxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQzFELHdDQUF3QyxTQUFTO0FBQ2pE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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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akI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlDQUFpQztBQUNqQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFnRTs7QUFFckU7O0FBRUEsbURBQW1ELGFBQWE7O0FBRWhFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZWlsaXNlYXJjaC9pbnN0YW50LW1laWxpc2VhcmNoL2Rpc3QvaW5zdGFudC1tZWlsaXNlYXJjaC51bWQuanM/NDAxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLndpbmRvdyA9IGdsb2JhbC53aW5kb3cgfHwge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbiAgICB9XG5cbiAgICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuKSB7XG4gICAgICB2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9O1xuICAgIFx0cmV0dXJuIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgICB9XG5cbiAgICB2YXIgYnJvd3NlclBvbHlmaWxsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgKGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIChmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICAgICAgIHZhciBzdXBwb3J0ID0ge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgICAgICAgICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgICAgICAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpLFxuICAgICAgICAgICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICAgICAgICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgdmlld0NsYXNzZXMgPSBbJ1tvYmplY3QgSW50OEFycmF5XScsICdbb2JqZWN0IFVpbnQ4QXJyYXldJywgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJywgJ1tvYmplY3QgSW50MTZBcnJheV0nLCAnW29iamVjdCBVaW50MTZBcnJheV0nLCAnW29iamVjdCBJbnQzMkFycmF5XScsICdbb2JqZWN0IFVpbnQzMkFycmF5XScsICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLCAnW29iamVjdCBGbG9hdDY0QXJyYXldJ107XG4gICAgICAgICAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgICAgICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICAgICAgICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICBpdGVtcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgICAgICAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgICAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgICAgICAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBidWYuc2xpY2UoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICAgICAgICAgIHJldHVybiB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAgICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICAgICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5qc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgICAgICAgICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcbiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgICAgICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICAgICAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgICAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbic7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWw7XG4gICAgICAgICAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7XG4gICAgICAgICAgICAgIGJvZHk6IHRoaXMuX2JvZHlJbml0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgICAgICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgICAgICAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICAgICAgICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICAgICAgICB9XG4gICAgICAgICAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcbiAgICAgICAgICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgdXJsOiB0aGlzLnVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG4gICAgICAgICAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbiAodXJsLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB1cmxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzLkRPTUV4Y2VwdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFzZWxmLmZldGNoKSB7XG4gICAgICAgICAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgICAgICAgICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgICAgICAgICAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICAgICAgICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgICAgICAgICBleHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgICAgICAgIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAgICAgICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgfSkoe30pO1xuICAgICAgfSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IGNvbW1vbmpzR2xvYmFsKTtcbiAgICB9KTtcblxuICAgIHZhciBtZWlsaXNlYXJjaF91bWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMsIGJyb3dzZXJQb2x5ZmlsbCkgO1xuICAgICAgfSkoY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgICAgICAgLy8gVHlwZSBkZWZpbml0aW9ucyBmb3IgbWVpbGlzZWFyY2hcbiAgICAgICAgLy8gUHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL21laWxpc2VhcmNoL21laWxpc2VhcmNoLWpzXG4gICAgICAgIC8vIERlZmluaXRpb25zIGJ5OiBxZGVxdWVsZSA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+IDxodHRwczovL2dpdGh1Yi5jb20vbWVpbGlzZWFyY2g+XG4gICAgICAgIC8vIERlZmluaXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vbWVpbGlzZWFyY2gvbWVpbGlzZWFyY2gtanNcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBWZXJzaW9uOiBeMy44LjNcblxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFNFQVJDSCBQQVJBTUVURVJTXHJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBNYXRjaGluZ1N0cmF0ZWdpZXMgPSB7XG4gICAgICAgICAgQUxMOiAnYWxsJyxcbiAgICAgICAgICBMQVNUOiAnbGFzdCdcbiAgICAgICAgfTtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcbiAgICAgICAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgICAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcbiAgICAgICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICAgICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICAgICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICAgICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAgICAgICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cblxuICAgICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICAgICAgICBfX3Byb3RvX186IFtdXG4gICAgICAgICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgICAgICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgICB2YXIgXyA9IHtcbiAgICAgICAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgICAgICAgIHNlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRyeXM6IFtdLFxuICAgICAgICAgICAgICBvcHM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB0LFxuICAgICAgICAgICAgZztcbiAgICAgICAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgICAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgICAgICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9KSwgZztcbiAgICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqL1xuICAgICAgICBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgX19leHRlbmRzKE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKG1lc3NhZ2UsIGJvZHksIHVybCwgc3RhY2spIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpczsgLy8gTWFrZSBlcnJvcnMgY29tcGFyaXNvbiBwb3NzaWJsZS4gZXg6IGVycm9yIGluc3RhbmNlb2YgTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IuXG5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3InO1xuICAgICAgICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgICAgICBfdGhpcy5tZXNzYWdlID0gYm9keS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0dXNDb2RlID0gYm9keS5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIF90aGlzLmVycm5vID0gYm9keS5lcnJubztcbiAgICAgICAgICAgICAgX3RoaXMuY29kZSA9IGJvZHkuY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgICBfdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICBfdGhpcy5zdGFjayA9IChfYSA9IF90aGlzLnN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvKFR5cGVFcnJvcnxGZXRjaEVycm9yKS8sIF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgICBfdGhpcy5zdGFjayA9IChfYiA9IF90aGlzLnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgnRmFpbGVkIHRvIGZldGNoJywgXCJyZXF1ZXN0IHRvIFwiLmNvbmNhdCh1cmwsIFwiIGZhaWxlZCwgcmVhc29uOiBjb25uZWN0IEVDT05OUkVGVVNFRFwiKSk7XG4gICAgICAgICAgICAgIF90aGlzLnN0YWNrID0gKF9jID0gX3RoaXMuc3RhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXBsYWNlKCdOb3QgRm91bmQnLCBcIk5vdCBGb3VuZDogXCIuY29uY2F0KHVybCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3I7XG4gICAgICAgIH0oRXJyb3IpO1xuICAgICAgICB2YXIgTWVpbGlTZWFyY2hBcGlFcnJvciA9IC8qKiBAY2xhc3MgKi9cbiAgICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoZXJyb3IsIHN0YXR1cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXJyb3IubWVzc2FnZSkgfHwgdGhpczsgLy8gTWFrZSBlcnJvcnMgY29tcGFyaXNvbiBwb3NzaWJsZS4gZXg6IGVycm9yIGluc3RhbmNlb2YgTWVpbGlTZWFyY2hBcGlFcnJvci5cblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWlsaVNlYXJjaEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gJ01laWxpU2VhcmNoQXBpRXJyb3InO1xuICAgICAgICAgICAgX3RoaXMuY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgICAgICBfdGhpcy50eXBlID0gZXJyb3IudHlwZTtcbiAgICAgICAgICAgIF90aGlzLmxpbmsgPSBlcnJvci5saW5rO1xuICAgICAgICAgICAgX3RoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBfdGhpcy5odHRwU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBNZWlsaVNlYXJjaEFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICAgIH0oRXJyb3IpO1xuICAgICAgICBmdW5jdGlvbiBodHRwUmVzcG9uc2VFcnJvckhhbmRsZXIocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VCb2R5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaWYgKCEhcmVzcG9uc2Uub2spIHJldHVybiBbM1xuICAgICAgICAgICAgICAgICAgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsLCA0XSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgcmVzcG9uc2UuanNvbigpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgcG9zc2libGUgdG8gcGFyc2UgdGhlIHJldHVybiBib2R5IGl0IG1lYW5zIHRoZXJlIGlzIG5vbmVcbiAgICAgICAgICAgICAgICAgIC8vIEluIHdoaWNoIGNhc2UgaXQgaXMgYSBjb21tdW5pY2F0aW9uIGVycm9yIHdpdGggdGhlIE1laWxpc2VhcmNoIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICByZXNwb25zZUJvZHkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWzNcbiAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgX2Euc2VudCgpOyAvLyBOb3Qgc3VyZSBvbiBob3cgdG8gdGVzdCB0aGlzIHBhcnQgb2YgdGhlIGNvZGUuXG5cbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCByZXNwb25zZSwgcmVzcG9uc2UudXJsKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYm9keSBpcyBwYXJzYWJsZSwgdGhlbiBpdCBtZWFucyBNZWlsaXNlYXJjaCByZXR1cm5lZCBhIGJvZHkgd2l0aFxuICAgICAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24gb24gdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoQXBpRXJyb3IocmVzcG9uc2VCb2R5LCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBodHRwRXJyb3JIYW5kbGVyKHJlc3BvbnNlLCBzdGFjaywgdXJsKSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLm5hbWUgIT09ICdNZWlsaVNlYXJjaEFwaUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKHJlc3BvbnNlLm1lc3NhZ2UsIHJlc3BvbnNlLCB1cmwsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1laWxpU2VhcmNoRXJyb3IgPSAvKiogQGNsYXNzICovXG4gICAgICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICBfX2V4dGVuZHMoTWVpbGlTZWFyY2hFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgICBmdW5jdGlvbiBNZWlsaVNlYXJjaEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7IC8vIE1ha2UgZXJyb3JzIGNvbXBhcmlzb24gcG9zc2libGUuIGV4OiBlcnJvciBpbnN0YW5jZW9mIE1laWxpU2VhcmNoRXJyb3IuXG5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVpbGlTZWFyY2hFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9ICdNZWlsaVNlYXJjaEVycm9yJztcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNZWlsaVNlYXJjaEVycm9yO1xuICAgICAgICB9KEVycm9yKTtcbiAgICAgICAgdmFyIE1laWxpU2VhcmNoVGltZU91dEVycm9yID0gLyoqIEBjbGFzcyAqL1xuICAgICAgICBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgX19leHRlbmRzKE1laWxpU2VhcmNoVGltZU91dEVycm9yLCBfc3VwZXIpO1xuICAgICAgICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoVGltZU91dEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7IC8vIE1ha2UgZXJyb3JzIGNvbXBhcmlzb24gcG9zc2libGUuIGV4OiBlcnJvciBpbnN0YW5jZW9mIE1laWxpU2VhcmNoVGltZU91dEVycm9yLlxuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1laWxpU2VhcmNoVGltZU91dEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gJ01laWxpU2VhcmNoVGltZU91dEVycm9yJztcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3I7XG4gICAgICAgIH0oRXJyb3IpO1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgdW5kZWZpbmVkIGVudHJpZXMgZnJvbSBvYmplY3RcclxuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVVbmRlZmluZWRGcm9tT2JqZWN0KG9iaikge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJFbnRyeSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGN1ckVudHJ5WzBdLFxuICAgICAgICAgICAgICB2YWwgPSBjdXJFbnRyeVsxXTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkgYWNjW2tleV0gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzbGVlcChtcykge1xuICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRQcm90b2NvbElmTm90UHJlc2VudChob3N0KSB7XG4gICAgICAgICAgaWYgKCEoaG9zdC5zdGFydHNXaXRoKCdodHRwczovLycpIHx8IGhvc3Quc3RhcnRzV2l0aCgnaHR0cDovLycpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cDovL1wiLmNvbmNhdChob3N0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkVHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgICAgICAgICBpZiAoIXVybC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBQQUNLQUdFX1ZFUlNJT04gPSAnMC4zMC4wJztcbiAgICAgICAgZnVuY3Rpb24gdG9RdWVyeVBhcmFtcyhwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICAgICAgICAgIHZhciBxdWVyeVBhcmFtcyA9IHBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWNjKSwgKF9hID0ge30sIF9hW2tleV0gPSB2YWx1ZS5qb2luKCcsJyksIF9hKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGFjYyksIChfYiA9IHt9LCBfYltrZXldID0gdmFsdWUudG9JU09TdHJpbmcoKSwgX2IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWNjKSwgKF9jID0ge30sIF9jW2tleV0gPSB2YWx1ZSwgX2MpKTtcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbnN0cnVjdEhvc3RVUkwoaG9zdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBob3N0ID0gYWRkUHJvdG9jb2xJZk5vdFByZXNlbnQoaG9zdCk7XG4gICAgICAgICAgICBob3N0ID0gYWRkVHJhaWxpbmdTbGFzaChob3N0KTtcbiAgICAgICAgICAgIHJldHVybiBob3N0O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKCdUaGUgcHJvdmlkZWQgaG9zdCBpcyBub3QgdmFsaWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIGFnZW50SGVhZGVyID0gJ1gtTWVpbGlzZWFyY2gtQ2xpZW50JztcbiAgICAgICAgICB2YXIgcGFja2FnZUFnZW50ID0gXCJNZWlsaXNlYXJjaCBKYXZhU2NyaXB0ICh2XCIuY29uY2F0KFBBQ0tBR0VfVkVSU0lPTiwgXCIpXCIpO1xuICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnO1xuICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcuaGVhZGVycyk7IC8vIENyZWF0ZSBhIGhhcmQgY29weSBhbmQgbm90IGEgcmVmZXJlbmNlIHRvIGNvbmZpZy5oZWFkZXJzXG5cbiAgICAgICAgICBpZiAoY29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gXCJCZWFyZXIgXCIuY29uY2F0KGNvbmZpZy5hcGlLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbmZpZy5oZWFkZXJzW2NvbnRlbnRUeXBlXSkge1xuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgfSAvLyBDcmVhdGVzIHRoZSBjdXN0b20gdXNlciBhZ2VudCB3aXRoIGluZm9ybWF0aW9uIG9uIHRoZSBwYWNrYWdlIHVzZWQuXG5cbiAgICAgICAgICBpZiAoY29uZmlnLmNsaWVudEFnZW50cyAmJiBBcnJheS5pc0FycmF5KGNvbmZpZy5jbGllbnRBZ2VudHMpKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50cyA9IGNvbmZpZy5jbGllbnRBZ2VudHMuY29uY2F0KHBhY2thZ2VBZ2VudCk7XG4gICAgICAgICAgICBoZWFkZXJzW2FnZW50SGVhZGVyXSA9IGNsaWVudHMuam9pbignIDsgJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuY2xpZW50QWdlbnRzICYmICFBcnJheS5pc0FycmF5KGNvbmZpZy5jbGllbnRBZ2VudHMpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIGlzIGRlZmluZWQgYnV0IG5vdCBhbiBhcnJheVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoRXJyb3IoXCJNZWlsaXNlYXJjaDogVGhlIGhlYWRlciBcXFwiXCIuY29uY2F0KGFnZW50SGVhZGVyLCBcIlxcXCIgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZyhzKS5cXG5cIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2FnZW50SGVhZGVyXSA9IHBhY2thZ2VBZ2VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEh0dHBSZXF1ZXN0cyA9IC8qKiBAY2xhc3MgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0cyhjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnMoY29uZmlnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBob3N0ID0gY29uc3RydWN0SG9zdFVSTChjb25maWcuaG9zdCk7XG4gICAgICAgICAgICAgIHRoaXMudXJsID0gbmV3IFVSTChob3N0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoRXJyb3IoJ1RoZSBwcm92aWRlZCBob3N0IGlzIG5vdCB2YWxpZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSHR0cFJlcXVlc3RzLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gX2EubWV0aG9kLFxuICAgICAgICAgICAgICB1cmwgPSBfYS51cmwsXG4gICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnBhcmFtcyxcbiAgICAgICAgICAgICAgYm9keSA9IF9hLmJvZHksXG4gICAgICAgICAgICAgIGNvbmZpZyA9IF9hLmNvbmZpZztcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdFVSTCwgcXVlcnlQYXJhbXNfMSwgcmVzcG9uc2UsIHBhcnNlZEJvZHksIGVfMSwgc3RhY2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdFVSTCA9IG5ldyBVUkwodXJsLCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc18xID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zW3hdICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zXzEuc2V0KHgsIHBhcmFtc1t4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0VVJMLnNlYXJjaCA9IHF1ZXJ5UGFyYW1zXzEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgNCwsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgZmV0Y2goY29uc3RydWN0VVJMLnRvU3RyaW5nKCksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb25maWcpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlRXJyb3JIYW5kbGVyKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBwYXJzZWRCb2R5XTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IGVfMS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgaHR0cEVycm9ySGFuZGxlcihlXzEsIHN0YWNrLCBjb25zdHJ1Y3RVUkwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbM1xuICAgICAgICAgICAgICAgICAgICAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBIdHRwUmVxdWVzdHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgcGFyYW1zLCBjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBIdHRwUmVxdWVzdHMucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgcGFyYW1zLCBjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBIdHRwUmVxdWVzdHM7XG4gICAgICAgIH0oKTtcbiAgICAgICAgdmFyIEVucXVldWVkVGFzayA9IC8qKiBAY2xhc3MgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIEVucXVldWVkVGFzayh0YXNrKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2tVaWQgPSB0YXNrLnRhc2tVaWQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4VWlkID0gdGFzay5pbmRleFVpZDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGFzay5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0YXNrLnR5cGU7XG4gICAgICAgICAgICB0aGlzLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gRW5xdWV1ZWRUYXNrO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBUYXNrID0gLyoqIEBjbGFzcyAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gVGFzayh0YXNrKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4VWlkID0gdGFzay5pbmRleFVpZDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGFzay5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0YXNrLnR5cGU7XG4gICAgICAgICAgICB0aGlzLnVpZCA9IHRhc2sudWlkO1xuICAgICAgICAgICAgdGhpcy5kZXRhaWxzID0gdGFzay5kZXRhaWxzO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxlZEJ5ID0gdGFzay5jYW5jZWxlZEJ5O1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRhc2suZXJyb3I7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gdGFzay5kdXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZEF0ID0gbmV3IERhdGUodGFzay5zdGFydGVkQXQpO1xuICAgICAgICAgICAgdGhpcy5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRBdCA9IG5ldyBEYXRlKHRhc2suZmluaXNoZWRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBUYXNrO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBUYXNrQ2xpZW50ID0gLyoqIEBjbGFzcyAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gVGFza0NsaWVudChjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3RzKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IG9uZSB0YXNrXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB1aWQgLSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFza1xyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHsgUHJvbWlzZTxUYXNrPiB9XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIFRhc2tDbGllbnQucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAodWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2tJdGVtO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInRhc2tzL1wiLmNvbmNhdCh1aWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFza0l0ZW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgVGFzayh0YXNrSXRlbSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRhc2tzXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHBhcmFtICB7VGFza3NRdWVyeX0gW3BhcmFtZXRlcnM9e31dIC0gUGFyYW1ldGVycyB0byBicm93c2UgdGhlIHRhc2tzXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VGFza3NSZXN1bHRzPn0gLSBQcm9taXNlIGNvbnRhaW5pbmcgYWxsIHRhc2tzXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIFRhc2tDbGllbnQucHJvdG90eXBlLmdldFRhc2tzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrcztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJ0YXNrc1wiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwsIHRvUXVlcnlQYXJhbXMocGFyYW1ldGVycykpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFza3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFza3MpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdGFza3MucmVzdWx0cy5tYXAoZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBXYWl0IGZvciBhIHRhc2sgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXNrVWlkIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICAgICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2s+fSBQcm9taXNlIHJldHVybmluZyBhIHRhc2sgYWZ0ZXIgaXQgaGFzIGJlZW4gcHJvY2Vzc2VkXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIFRhc2tDbGllbnQucHJvdG90eXBlLndhaXRGb3JUYXNrID0gZnVuY3Rpb24gKHRhc2tVaWQsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSxcbiAgICAgICAgICAgICAgX2MgPSBfYi50aW1lT3V0TXMsXG4gICAgICAgICAgICAgIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsXG4gICAgICAgICAgICAgIF9kID0gX2IuaW50ZXJ2YWxNcyxcbiAgICAgICAgICAgICAgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRpbmdUaW1lLCByZXNwb25zZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShEYXRlLm5vdygpIC0gc3RhcnRpbmdUaW1lIDwgdGltZU91dE1zKSkgcmV0dXJuIFszXG4gICAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuZ2V0VGFzayh0YXNrVWlkKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVtcImVucXVldWVkXCJcbiAgICAgICAgICAgICAgICAgICAgLyogVEFTS19FTlFVRVVFRCAqLywgXCJwcm9jZXNzaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgLyogVEFTS19QUk9DRVNTSU5HICovXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCBzbGVlcChpbnRlcnZhbE1zKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszXG4gICAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvcihcInRpbWVvdXQgb2YgXCIuY29uY2F0KHRpbWVPdXRNcywgXCJtcyBoYXMgZXhjZWVkZWQgb24gcHJvY2VzcyBcIikuY29uY2F0KHRhc2tVaWQsIFwiIHdoZW4gd2FpdGluZyBhIHRhc2sgdG8gYmUgcmVzb2x2ZWQuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFdhaXRzIGZvciBtdWx0aXBsZSB0YXNrcyB0byBiZSBwcm9jZXNzZWRcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0YXNrVWlkcyBUYXNrcyBpZGVudGlmaWVyIGxpc3RcclxuICAgICAgICAgICAqIEBwYXJhbSB7V2FpdE9wdGlvbnN9IG9wdGlvbnMgV2FpdCBvcHRpb25zXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VGFza1tdPn0gUHJvbWlzZSByZXR1cm5pbmcgYSBsaXN0IG9mIHRhc2tzIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIHByb2Nlc3NlZFxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFza3MgPSBmdW5jdGlvbiAodGFza1VpZHMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSxcbiAgICAgICAgICAgICAgX2MgPSBfYi50aW1lT3V0TXMsXG4gICAgICAgICAgICAgIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsXG4gICAgICAgICAgICAgIF9kID0gX2IuaW50ZXJ2YWxNcyxcbiAgICAgICAgICAgICAgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdGFza3MsIF9pLCB0YXNrVWlkc18xLCB0YXNrVWlkLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIHRhc2tVaWRzXzEgPSB0YXNrVWlkcztcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IHRhc2tVaWRzXzEubGVuZ3RoKSkgcmV0dXJuIFszXG4gICAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIHRhc2tVaWQgPSB0YXNrVWlkc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy53YWl0Rm9yVGFzayh0YXNrVWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszXG4gICAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0YXNrc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBDYW5jZWwgYSBsaXN0IG9mIGVucXVldWVkIG9yIHByb2Nlc3NpbmcgdGFza3MuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgVGFza3NcclxuICAgICAgICAgICAqIEBtZXRob2QgY2FuY2VsVGFza3NcclxuICAgICAgICAgICAqIEBwYXJhbSB7Q2FuY2VsVGFza3NRdWVyeX0gW3BhcmFtZXRlcnM9e31dIC0gUGFyYW1ldGVycyB0byBmaWx0ZXIgdGhlIHRhc2tzLlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgVGFza0NsaWVudC5wcm90b3R5cGUuY2FuY2VsVGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwidGFza3MvY2FuY2VsXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHt9LCB0b1F1ZXJ5UGFyYW1zKHBhcmFtZXRlcnMpKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIERlbGV0ZSBhIGxpc3QgdGFza3MuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgVGFza3NcclxuICAgICAgICAgICAqIEBtZXRob2QgZGVsZXRlVGFza3NcclxuICAgICAgICAgICAqIEBwYXJhbSB7RGVsZXRlVGFza3NRdWVyeX0gW3BhcmFtZXRlcnM9e31dIC0gUGFyYW1ldGVycyB0byBmaWx0ZXIgdGhlIHRhc2tzLlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgVGFza0NsaWVudC5wcm90b3R5cGUuZGVsZXRlVGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwidGFza3NcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwsIHt9LCB0b1F1ZXJ5UGFyYW1zKHBhcmFtZXRlcnMpKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gVGFza0NsaWVudDtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogQnVuZGxlOiBNZWlsaVNlYXJjaCAvIEluZGV4ZXNcclxuICAgICAgICAgKiBQcm9qZWN0OiBNZWlsaVNlYXJjaCAtIEphdmFzY3JpcHQgQVBJXHJcbiAgICAgICAgICogQXV0aG9yOiBRdWVudGluIGRlIFF1ZWxlbiA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+XHJcbiAgICAgICAgICogQ29weXJpZ2h0OiAyMDE5LCBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBJbmRleCA9IC8qKiBAY2xhc3MgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQHBhcmFtIHtDb25maWd9IGNvbmZpZyBSZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBVSUQgb2YgdGhlIGluZGV4XHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByaW1hcnlLZXldIFByaW1hcnkgS2V5IG9mIHRoZSBpbmRleFxyXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gSW5kZXgoY29uZmlnLCB1aWQsIHByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5S2V5ID0gcHJpbWFyeUtleTtcbiAgICAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3RzKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnRhc2tzID0gbmV3IFRhc2tDbGllbnQoY29uZmlnKTtcbiAgICAgICAgICB9IC8vL1xuICAgICAgICAgIC8vLyBTRUFSQ0hcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogU2VhcmNoIGZvciBkb2N1bWVudHMgaW50byBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHNlYXJjaFxyXG4gICAgICAgICAgICogQHRlbXBsYXRlIFRcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcXVlcnk/IFF1ZXJ5IHN0cmluZ1xyXG4gICAgICAgICAgICogQHBhcmFtIHtTZWFyY2hQYXJhbXN9IG9wdGlvbnM/IFNlYXJjaCBvcHRpb25zXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge1BhcnRpYWw8UmVxdWVzdD59IGNvbmZpZz8gQWRkaXRpb25hbCByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2VhcmNoUmVzcG9uc2U8VD4+fSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHNlYXJjaCByZXNwb25zZVxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHF1ZXJ5LCBvcHRpb25zLCBjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2VhcmNoXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCByZW1vdmVVbmRlZmluZWRGcm9tT2JqZWN0KF9fYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICBxOiBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSksIHVuZGVmaW5lZCwgY29uZmlnKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogU2VhcmNoIGZvciBkb2N1bWVudHMgaW50byBhbiBpbmRleCB1c2luZyB0aGUgR0VUIG1ldGhvZFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHNlYXJjaFxyXG4gICAgICAgICAgICogQHRlbXBsYXRlIFRcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcXVlcnk/IFF1ZXJ5IHN0cmluZ1xyXG4gICAgICAgICAgICogQHBhcmFtIHtTZWFyY2hQYXJhbXN9IG9wdGlvbnM/IFNlYXJjaCBvcHRpb25zXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge1BhcnRpYWw8UmVxdWVzdD59IGNvbmZpZz8gQWRkaXRpb25hbCByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2VhcmNoUmVzcG9uc2U8VD4+fSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHNlYXJjaCByZXNwb25zZVxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuc2VhcmNoR2V0ID0gZnVuY3Rpb24gKHF1ZXJ5LCBvcHRpb25zLCBjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHBhcnNlRmlsdGVyLCBnZXRQYXJhbXM7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NlYXJjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWx0ZXIgPSBmdW5jdGlvbiBwYXJzZUZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHJldHVybiBmaWx0ZXI7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIGZpbHRlciBxdWVyeSBwYXJhbWV0ZXIgc2hvdWxkIGJlIGluIHN0cmluZyBmb3JtYXQgd2hlbiB1c2luZyBzZWFyY2hHZXQnKTtlbHNlIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICBxOiBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSwge1xuICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogcGFyc2VGaWx0ZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlciksXG4gICAgICAgICAgICAgICAgICAgICAgc29ydDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2luKCcsJyksXG4gICAgICAgICAgICAgICAgICAgICAgZmFjZXRzOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFjZXRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuam9pbignLCcpLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1RvUmV0cmlldmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5qb2luKCcsJyksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1RvQ3JvcDogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXNUb0Nyb3ApID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5qb2luKCcsJyksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1RvSGlnaGxpZ2h0OiAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1RvSGlnaGxpZ2h0KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuam9pbignLCcpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwsIHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3QoZ2V0UGFyYW1zKSwgY29uZmlnKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfZi5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gSU5ERVhcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IGluZGV4IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldFJhd0luZm9cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleE9iamVjdD59IFByb21pc2UgY29udGFpbmluZyBpbmRleCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuZ2V0UmF3SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgcmVzO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5S2V5ID0gcmVzLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZEF0ID0gbmV3IERhdGUocmVzLnVwZGF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gbmV3IERhdGUocmVzLmNyZWF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCByZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogRmV0Y2ggYW5kIHVwZGF0ZSBJbmRleCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBmZXRjaEluZm9cclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHRoaXM+fSBQcm9taXNlIHRvIHRoZSBjdXJyZW50IEluZGV4IG9iamVjdCB3aXRoIHVwZGF0ZWQgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmZldGNoSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5nZXRSYXdJbmZvKCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0aGlzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEdldCBQcmltYXJ5IEtleS5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBmZXRjaFByaW1hcnlLZXlcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD59IFByb21pc2UgY29udGFpbmluZyB0aGUgUHJpbWFyeSBLZXkgb2YgdGhlIGluZGV4XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5mZXRjaFByaW1hcnlLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmdldFJhd0luZm8oKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9hLnByaW1hcnlLZXkgPSBfYi5zZW50KCkucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIHRoaXMucHJpbWFyeUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBDcmVhdGUgYW4gaW5kZXguXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgICAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgSW5kZXhcclxuICAgICAgICAgICAqIEBwYXJhbSB7SW5kZXhPcHRpb25zfSBvcHRpb25zIEluZGV4IG9wdGlvbnNcclxuICAgICAgICAgICAqIEBwYXJhbSB7Q29uZmlnfSBjb25maWcgUmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IE5ld2x5IGNyZWF0ZWQgSW5kZXggb2JqZWN0XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LmNyZWF0ZSA9IGZ1bmN0aW9uICh1aWQsIG9wdGlvbnMsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHJlcSwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzXCI7XG4gICAgICAgICAgICAgICAgICAgIHJlcSA9IG5ldyBIdHRwUmVxdWVzdHMoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgcmVxLnBvc3QodXJsLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICB9KSldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBVcGRhdGUgYW4gaW5kZXguXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0luZGV4T3B0aW9uc30gZGF0YSBEYXRhIHRvIHVwZGF0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59IFByb21pc2UgdG8gdGhlIGN1cnJlbnQgSW5kZXggb2JqZWN0IHdpdGggdXBkYXRlZCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucGF0Y2godXJsLCBkYXRhKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0YXNrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIERlbGV0ZSBhbiBpbmRleC5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBkZWxldGVcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gaW5kZXggaXMgZGVsZXRlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gVEFTS1NcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCB0aGUgdGFza3Mgb2YgdGhlIGluZGV4LlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleGVzXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldFRhc2tzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge1Rhc2tzUXVlcnl9IFtwYXJhbWV0ZXJzPXt9XSAtIFBhcmFtZXRlcnMgdG8gYnJvd3NlIHRoZSB0YXNrc1xyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2tzUmVzdWx0cz59IC0gUHJvbWlzZSBjb250YWluaW5nIGFsbCB0YXNrc1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuZ2V0VGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMudGFza3MuZ2V0VGFza3MoX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtZXRlcnMpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXhVaWRzOiBbdGhpcy51aWRdXG4gICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IG9uZSB0YXNrIG9mIHRoZSBpbmRleC5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhlc1xyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRUYXNrXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFza1VpZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2s+fSAtIFByb21pc2UgY29udGFpbmluZyBhIHRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAodGFza1VpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldFRhc2sodGFza1VpZCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFdhaXQgZm9yIG11bHRpcGxlIHRhc2tzIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhlc1xyXG4gICAgICAgICAgICogQG1ldGhvZCB3YWl0Rm9yVGFza3NcclxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRhc2tVaWRzIC0gVGFza3MgaWRlbnRpZmllclxyXG4gICAgICAgICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VGFza1tdPn0gLSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLndhaXRGb3JUYXNrcyA9IGZ1bmN0aW9uICh0YXNrVWlkcywgX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICAgICAgICBfYyA9IF9iLnRpbWVPdXRNcyxcbiAgICAgICAgICAgICAgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYyxcbiAgICAgICAgICAgICAgX2QgPSBfYi5pbnRlcnZhbE1zLFxuICAgICAgICAgICAgICBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvclRhc2tzKHRhc2tVaWRzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfZS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogV2FpdCBmb3IgYSB0YXNrIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhlc1xyXG4gICAgICAgICAgICogQG1ldGhvZCB3YWl0Rm9yVGFza1xyXG4gICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tVaWQgLSBUYXNrIGlkZW50aWZpZXJcclxuICAgICAgICAgICAqIEBwYXJhbSB7V2FpdE9wdGlvbnN9IHdhaXRPcHRpb25zIC0gT3B0aW9ucyBvbiB0aW1lb3V0IGFuZCBpbnRlcnZhbFxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2s+fSAtIFByb21pc2UgY29udGFpbmluZyBhbiBhcnJheSBvZiB0YXNrc1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUud2FpdEZvclRhc2sgPSBmdW5jdGlvbiAodGFza1VpZCwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICAgICAgICBfYyA9IF9iLnRpbWVPdXRNcyxcbiAgICAgICAgICAgICAgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYyxcbiAgICAgICAgICAgICAgX2QgPSBfYi5pbnRlcnZhbE1zLFxuICAgICAgICAgICAgICBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvclRhc2sodGFza1VpZCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsTXM6IGludGVydmFsTXNcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8vXG4gICAgICAgICAgLy8vIFNUQVRTXG4gICAgICAgICAgLy8vXG5cbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIGdldCBzdGF0cyBvZiBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldFN0YXRzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleFN0YXRzPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCB3aXRoIHN0YXRzIG9mIHRoZSBpbmRleFxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3N0YXRzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBET0NVTUVOVFNcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogZ2V0IGRvY3VtZW50cyBvZiBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldERvY3VtZW50c1xyXG4gICAgICAgICAgICogQHRlbXBsYXRlIFRcclxuICAgICAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnRzUXVlcnk8VD59IFtwYXJhbWV0ZXJzPXt9XSBQYXJhbWV0ZXJzIHRvIGJyb3dzZSB0aGUgZG9jdW1lbnRzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEb2N1bWVudHNSZXN1bHRzPFQ+Pj59IFByb21pc2UgY29udGFpbmluZyBEb2N1bWVudCByZXNwb25zZXNcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmdldERvY3VtZW50cyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgZmllbGRzO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLmZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBwYXJhbWV0ZXJzID09PSBudWxsIHx8IHBhcmFtZXRlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtZXRlcnMuZmllbGRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1ldGVycyksIHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICB9KSkpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgb25lIGRvY3VtZW50XHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2V0RG9jdW1lbnRcclxuICAgICAgICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gZG9jdW1lbnRJZCBEb2N1bWVudCBJRFxyXG4gICAgICAgICAgICogQHBhcmFtIHtEb2N1bWVudFF1ZXJ5PFQ+fSBbcGFyYW1ldGVycz17fV0gUGFyYW1ldGVycyBhcHBsaWVkIG9uIGEgZG9jdW1lbnRcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERvY3VtZW50PFQ+Pn0gUHJvbWlzZSBjb250YWluaW5nIERvY3VtZW50IHJlc3BvbnNlXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudElkLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIGZpZWxkcztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzL1wiKS5jb25jYXQoZG9jdW1lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLmZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBwYXJhbWV0ZXJzID09PSBudWxsIHx8IHBhcmFtZXRlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtZXRlcnMuZmllbGRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1ldGVycyksIHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICB9KSkpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBBZGQgb3IgcmVwbGFjZSBtdWx0aXBsZXMgZG9jdW1lbnRzIHRvIGFuIGluZGV4XHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgYWRkRG9jdW1lbnRzXHJcbiAgICAgICAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC9yZXBsYWNlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50T3B0aW9uc30gb3B0aW9ucz8gT3B0aW9ucyBvbiBkb2N1bWVudCBhZGRpdGlvblxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmFkZERvY3VtZW50cyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBkb2N1bWVudHMsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQWRkIG9yIHJlcGxhY2UgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleCBpbiBiYXRjaGVzXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgYWRkRG9jdW1lbnRzSW5CYXRjaGVzXHJcbiAgICAgICAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC9yZXBsYWNlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmF0Y2hTaXplIFNpemUgb2YgdGhlIGJhdGNoXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50T3B0aW9uc30gb3B0aW9ucz8gT3B0aW9ucyBvbiBkb2N1bWVudCBhZGRpdGlvblxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrcz59IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBlbnF1ZXVlZCB0YXNrIG9iamVjdHMgZm9yIGVhY2ggYmF0Y2hcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmFkZERvY3VtZW50c0luQmF0Y2hlcyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIGJhdGNoU2l6ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cGRhdGVzLCBpLCBfYSwgX2I7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGRvY3VtZW50cy5sZW5ndGgpKSByZXR1cm4gWzNcbiAgICAgICAgICAgICAgICAgICAgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB1cGRhdGVzKS5wdXNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmFkZERvY3VtZW50cyhkb2N1bWVudHMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSksIG9wdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpICs9IGJhdGNoU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszXG4gICAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB1cGRhdGVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEFkZCBvciB1cGRhdGUgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZURvY3VtZW50c1xyXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxQYXJ0aWFsPFQ+Pj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC91cGRhdGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnRPcHRpb25zfSBvcHRpb25zPyBPcHRpb25zIG9uIGRvY3VtZW50IHVwZGF0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnRzID0gZnVuY3Rpb24gKGRvY3VtZW50cywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucHV0KHVybCwgZG9jdW1lbnRzLCBvcHRpb25zKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEFkZCBvciB1cGRhdGUgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleCBpbiBiYXRjaGVzXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlRG9jdW1lbnRzXHJcbiAgICAgICAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC91cGRhdGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXRjaFNpemUgU2l6ZSBvZiB0aGUgYmF0Y2hcclxuICAgICAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnRPcHRpb25zfSBvcHRpb25zPyBPcHRpb25zIG9uIGRvY3VtZW50IHVwZGF0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrcz59IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBlbnF1ZXVlZCB0YXNrIG9iamVjdHMgZm9yIGVhY2ggYmF0Y2hcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50c0luQmF0Y2hlcyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIGJhdGNoU2l6ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cGRhdGVzLCBpLCBfYSwgX2I7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGRvY3VtZW50cy5sZW5ndGgpKSByZXR1cm4gWzNcbiAgICAgICAgICAgICAgICAgICAgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB1cGRhdGVzKS5wdXNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLnVwZGF0ZURvY3VtZW50cyhkb2N1bWVudHMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSksIG9wdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpICs9IGJhdGNoU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszXG4gICAgICAgICAgICAgICAgICAgIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB1cGRhdGVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIERlbGV0ZSBvbmUgZG9jdW1lbnRcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBkZWxldGVEb2N1bWVudFxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGRvY3VtZW50SWQgSWQgb2YgRG9jdW1lbnQgdG8gZGVsZXRlXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL2RvY3VtZW50cy9cIikuY29uY2F0KGRvY3VtZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgdGFza107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBEZWxldGUgbXVsdGlwbGVzIGRvY3VtZW50cyBvZiBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGRlbGV0ZURvY3VtZW50c1xyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXSB8IG51bWJlcltdfSBkb2N1bWVudHNJZHMgQXJyYXkgb2YgRG9jdW1lbnQgSWRzIHRvIGRlbGV0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuZGVsZXRlRG9jdW1lbnRzID0gZnVuY3Rpb24gKGRvY3VtZW50c0lkcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvZGVsZXRlLWJhdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBkb2N1bWVudHNJZHMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogRGVsZXRlIGFsbCBkb2N1bWVudHMgb2YgYW4gaW5kZXhcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBkZWxldGVBbGxEb2N1bWVudHNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmRlbGV0ZUFsbERvY3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgdGFza107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBTRVRUSU5HU1xuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBSZXRyaWV2ZSBhbGwgc2V0dGluZ3NcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRTZXR0aW5nc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2V0dGluZ3M+fSBQcm9taXNlIGNvbnRhaW5pbmcgU2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3NcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFVwZGF0ZSBhbGwgc2V0dGluZ3NcclxuICAgICAgICAgICAqIEFueSBwYXJhbWV0ZXJzIG5vdCBwcm92aWRlZCB3aWxsIGJlIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVNldHRpbmdzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge1NldHRpbmdzfSBzZXR0aW5ncyBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHdpdGggdGhlaXIgdXBkYXRlZCB2YWx1ZXNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBhdGNoKHVybCwgc2V0dGluZ3MpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0YXNrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFJlc2V0IHNldHRpbmdzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHJlc2V0U2V0dGluZ3NcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgdGFza107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBQQUdJTkFUSU9OIFNFVFRJTkdTXG4gICAgICAgICAgLy8vXG5cbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEdldCB0aGUgcGFnaW5hdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRQYWdpbmF0aW9uXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQYWdpbmF0aW9uU2V0dGluZz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgcGFnaW5hdGlvbiBzZXR0aW5nc1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuZ2V0UGFnaW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcGFnaW5hdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogVXBkYXRlIHRoZSBwYWdpbmF0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVBhZ2luYXRpb25cclxuICAgICAgICAgICAqIEBwYXJhbSB7UGFnaW5hdGlvblNldHRpbmdzfSBwYWdpbmF0aW9uIFBhZ2luYXRpb24gb2JqZWN0XHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVQYWdpbmF0aW9uID0gZnVuY3Rpb24gKHBhZ2luYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcGFnaW5hdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wYXRjaCh1cmwsIHBhZ2luYXRpb24pXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogUmVzZXQgdGhlIHBhZ2luYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgcmVzZXRQYWdpbmF0aW9uXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFBhZ2luYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3BhZ2luYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8vXG4gICAgICAgICAgLy8vIFNZTk9OWU1TXG4gICAgICAgICAgLy8vXG5cbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgc3lub255bXNcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRTeW5vbnltc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiBzeW5vbnltIG1hcHBpbmdzXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXRTeW5vbnltcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3lub255bXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBzeW5vbnltcy4gT3ZlcndyaXRlIHRoZSBvbGQgbGlzdC5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTeW5vbnltc1xyXG4gICAgICAgICAgICogQHBhcmFtIHtTeW5vbnltc30gc3lub255bXMgTWFwcGluZyBvZiBzeW5vbnltcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd29yZHNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVN5bm9ueW1zID0gZnVuY3Rpb24gKHN5bm9ueW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3N5bm9ueW1zXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIHN5bm9ueW1zKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFJlc2V0IHRoZSBzeW5vbnltIGxpc3QgdG8gYmUgZW1wdHkgYWdhaW5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCByZXNldFN5bm9ueW1zXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN5bm9ueW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zeW5vbnltc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIHRhc2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gU1RPUCBXT1JEU1xuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsIHN0b3Atd29yZHNcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRTdG9wV29yZHNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIHN0b3Atd29yZHNcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmdldFN0b3BXb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogVXBkYXRlIHRoZSBsaXN0IG9mIHN0b3Atd29yZHMuIE92ZXJ3cml0ZSB0aGUgb2xkIGxpc3QuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlU3RvcFdvcmRzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge1N0b3BXb3Jkc30gc3RvcFdvcmRzIEFycmF5IG9mIHN0cmluZ3MgdGhhdCBjb250YWlucyB0aGUgc3RvcC13b3Jkcy5cclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVN0b3BXb3JkcyA9IGZ1bmN0aW9uIChzdG9wV29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBzdG9wV29yZHMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogUmVzZXQgdGhlIHN0b3Atd29yZHMgbGlzdCB0byBiZSBlbXB0eSBhZ2FpblxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHJlc2V0U3RvcFdvcmRzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN0b3BXb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIHRhc2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gUkFOS0lORyBSVUxFU1xuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsIHJhbmtpbmctcnVsZXNcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRSYW5raW5nUnVsZXNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIHJhbmtpbmctcnVsZXNcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmdldFJhbmtpbmdSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcmFua2luZy1ydWxlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogVXBkYXRlIHRoZSBsaXN0IG9mIHJhbmtpbmctcnVsZXMuIE92ZXJ3cml0ZSB0aGUgb2xkIGxpc3QuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmFua2luZ1J1bGVzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge1JhbmtpbmdSdWxlc30gcmFua2luZ1J1bGVzIEFycmF5IHRoYXQgY29udGFpbiByYW5raW5nIHJ1bGVzIHNvcnRlZCBieSBvcmRlciBvZiBpbXBvcnRhbmNlLlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlUmFua2luZ1J1bGVzID0gZnVuY3Rpb24gKHJhbmtpbmdSdWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIHJhbmtpbmdSdWxlcyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBSZXNldCB0aGUgcmFua2luZyBydWxlcyBsaXN0IHRvIGl0cyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgcmVzZXRSYW5raW5nUnVsZXNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnJlc2V0UmFua2luZ1J1bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgdGFza107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBESVNUSU5DVCBBVFRSSUJVVEVcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGVcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXREaXN0aW5jdEF0dHJpYnV0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgbnVsbD59IFByb21pc2UgY29udGFpbmluZyB0aGUgZGlzdGluY3QtYXR0cmlidXRlIG9mIHRoZSBpbmRleFxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUuZ2V0RGlzdGluY3RBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3RpbmN0LWF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogVXBkYXRlIHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlRGlzdGluY3RBdHRyaWJ1dGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RGlzdGluY3RBdHRyaWJ1dGV9IGRpc3RpbmN0QXR0cmlidXRlIEZpZWxkIG5hbWUgb2YgdGhlIGRpc3RpbmN0LWF0dHJpYnV0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRGlzdGluY3RBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZGlzdGluY3RBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIGRpc3RpbmN0QXR0cmlidXRlKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFJlc2V0IHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgcmVzZXREaXN0aW5jdEF0dHJpYnV0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUucmVzZXREaXN0aW5jdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgdGFza107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBGSUxURVJBQkxFIEFUVFJJQlVURVNcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBmaWx0ZXJhYmxlLWF0dHJpYnV0ZXNcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRGaWx0ZXJhYmxlQXR0cmlidXRlc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXRGaWx0ZXJhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBVcGRhdGUgdGhlIGZpbHRlcmFibGUtYXR0cmlidXRlcy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVGaWx0ZXJhYmxlQXR0cmlidXRlc1xyXG4gICAgICAgICAgICogQHBhcmFtIHtGaWx0ZXJhYmxlQXR0cmlidXRlc30gZmlsdGVyYWJsZUF0dHJpYnV0ZXMgQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgZmlsdGVycyBhdCBxdWVyeSB0aW1lXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVGaWx0ZXJhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChmaWx0ZXJhYmxlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9maWx0ZXJhYmxlLWF0dHJpYnV0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucHV0KHVybCwgZmlsdGVyYWJsZUF0dHJpYnV0ZXMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogUmVzZXQgdGhlIGZpbHRlcmFibGUtYXR0cmlidXRlcy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCByZXNldEZpbHRlcmFibGVBdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5yZXNldEZpbHRlcmFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9maWx0ZXJhYmxlLWF0dHJpYnV0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0YXNrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8vXG4gICAgICAgICAgLy8vIFNPUlRBQkxFIEFUVFJJQlVURVNcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBzb3J0YWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2V0U29ydGFibGVBdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBzb3J0YWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXRTb3J0YWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3NvcnRhYmxlLWF0dHJpYnV0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFVwZGF0ZSB0aGUgc29ydGFibGUtYXR0cmlidXRlcy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTb3J0YWJsZUF0dHJpYnV0ZXNcclxuICAgICAgICAgICAqIEBwYXJhbSB7U29ydGFibGVBdHRyaWJ1dGVzfSBzb3J0YWJsZUF0dHJpYnV0ZXMgQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gc29ydCBzZWFyY2ggcmVzdWx0cyBhdCBxdWVyeSB0aW1lXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVTb3J0YWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc29ydGFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3NvcnRhYmxlLWF0dHJpYnV0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucHV0KHVybCwgc29ydGFibGVBdHRyaWJ1dGVzKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFJlc2V0IHRoZSBzb3J0YWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHJlc2V0U29ydGFibGVBdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFNvcnRhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc29ydGFibGUtYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIHRhc2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gU0VBUkNIQUJMRSBBVFRSSUJVVEVcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBzZWFyY2hhYmxlLWF0dHJpYnV0ZXNcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRTZWFyY2hhYmxlQXR0cmlidXRlc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZWFyY2hhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBVcGRhdGUgdGhlIHNlYXJjaGFibGUtYXR0cmlidXRlcy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTZWFyY2hhYmxlQXR0cmlidXRlc1xyXG4gICAgICAgICAgICogQHBhcmFtIHtTZWFyY2hhYmxlQXR0cmlidXRlc30gc2VhcmNoYWJsZUF0dHJpYnV0ZXMgQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGNvbnRhaW5zIHNlYXJjaGFibGUgYXR0cmlidXRlcyBzb3J0ZWQgYnkgb3JkZXIgb2YgaW1wb3J0YW5jZShtb3N0IHRvIGxlYXN0IGltcG9ydGFudClcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVNlYXJjaGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHNlYXJjaGFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3NlYXJjaGFibGUtYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBzZWFyY2hhYmxlQXR0cmlidXRlcyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBSZXNldCB0aGUgc2VhcmNoYWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3NlYXJjaGFibGUtYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIHRhc2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gRElTUExBWUVEIEFUVFJJQlVURVxuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgdGhlIGRpc3BsYXllZC1hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2V0RGlzcGxheWVkQXR0cmlidXRlc1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZGlzcGxheWVkLWF0dHJpYnV0ZXNcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmdldERpc3BsYXllZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3BsYXllZC1hdHRyaWJ1dGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZC1hdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZURpc3BsYXllZEF0dHJpYnV0ZXNcclxuICAgICAgICAgICAqIEBwYXJhbSB7RGlzcGxheWVkQXR0cmlidXRlc30gZGlzcGxheWVkQXR0cmlidXRlcyBBcnJheSBvZiBzdHJpbmdzIHRoYXQgY29udGFpbnMgYXR0cmlidXRlcyBvZiBhbiBpbmRleCB0byBkaXNwbGF5XHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGRpc3BsYXllZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzcGxheWVkLWF0dHJpYnV0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucHV0KHVybCwgZGlzcGxheWVkQXR0cmlidXRlcyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBSZXNldCB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgcmVzZXREaXNwbGF5ZWRBdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5yZXNldERpc3BsYXllZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3BsYXllZC1hdHRyaWJ1dGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgdGFza107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBUWVBPIFRPTEVSQU5DRVxuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgdGhlIHR5cG8gdG9sZXJhbmNlIHNldHRpbmdzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldFR5cG9Ub2xlcmFuY2VcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSB0eXBvIHRvbGVyYW5jZSBzZXR0aW5ncy5cclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgSW5kZXgucHJvdG90eXBlLmdldFR5cG9Ub2xlcmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3R5cG8tdG9sZXJhbmNlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBVcGRhdGUgdGhlIHR5cG8gdG9sZXJhbmNlIHNldHRpbmdzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVR5cG9Ub2xlcmFuY2VcclxuICAgICAgICAgICAqIEBwYXJhbSB7VHlwb1RvbGVyYW5jZX0gdHlwb1RvbGVyYW5jZSBPYmplY3QgY29udGFpbmluZyB0aGUgY3VzdG9tIHR5cG8gdG9sZXJhbmNlIHNldHRpbmdzLlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVUeXBvVG9sZXJhbmNlID0gZnVuY3Rpb24gKHR5cG9Ub2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvdHlwby10b2xlcmFuY2VcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucGF0Y2godXJsLCB0eXBvVG9sZXJhbmNlKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0YXNrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFJlc2V0IHRoZSB0eXBvIHRvbGVyYW5jZSBzZXR0aW5ncy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCByZXNldFR5cG9Ub2xlcmFuY2VcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUucmVzZXRUeXBvVG9sZXJhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy90eXBvLXRvbGVyYW5jZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIHRhc2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gRkFDRVRJTkdcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBmYWNldGluZyBzZXR0aW5ncy5cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRGYWNldGluZ1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmFjZXRpbmc+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIGZhY2V0aW5nIGluZGV4IHNldHRpbmdzXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIEluZGV4LnByb3RvdHlwZS5nZXRGYWNldGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmFjZXRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZmFjZXRpbmcgc2V0dGluZ3MuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlRmFjZXRpbmdcclxuICAgICAgICAgICAqIEBwYXJhbSB7RmFjZXRpbmd9IGZhY2V0aW5nIEZhY2V0aW5nIGluZGV4IHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRmFjZXRpbmcgPSBmdW5jdGlvbiAoZmFjZXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmFjZXRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucGF0Y2godXJsLCBmYWNldGluZyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBSZXNldCB0aGUgZmFjZXRpbmcgc2V0dGluZ3MuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAgICAgICAqIEBtZXRob2QgcmVzZXRGYWNldGluZ1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBJbmRleC5wcm90b3R5cGUucmVzZXRGYWNldGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmFjZXRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gSW5kZXg7XG4gICAgICAgIH0oKTtcblxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEJ1bmRsZTogTWVpbGlTZWFyY2hcclxuICAgICAgICAgKiBQcm9qZWN0OiBNZWlsaVNlYXJjaCAtIEphdmFzY3JpcHQgQVBJXHJcbiAgICAgICAgICogQXV0aG9yOiBRdWVudGluIGRlIFF1ZWxlbiA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+XHJcbiAgICAgICAgICogQ29weXJpZ2h0OiAyMDE5LCBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBDbGllbnQgPSAvKiogQGNsYXNzICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIENyZWF0ZXMgbmV3IE1laWxpU2VhcmNoIGluc3RhbmNlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBDbGllbnQoY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3RzKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnRhc2tzID0gbmV3IFRhc2tDbGllbnQoY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBSZXR1cm4gYW4gSW5kZXggaW5zdGFuY2VcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAgICogQG1ldGhvZCBpbmRleFxyXG4gICAgICAgICAgICogQHRlbXBsYXRlIFRcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleFVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7SW5kZXg8VD59IEluc3RhbmNlIG9mIEluZGV4XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5kZXgodGhpcy5jb25maWcsIGluZGV4VWlkKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2F0aGVyIGluZm9ybWF0aW9uIGFib3V0IGFuIGluZGV4IGJ5IGNhbGxpbmcgTWVpbGlTZWFyY2ggYW5kXHJcbiAgICAgICAgICAgKiByZXR1cm4gYW4gSW5kZXggaW5zdGFuY2Ugd2l0aCB0aGUgZ2F0aGVyZWQgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRJbmRleFxyXG4gICAgICAgICAgICogQHRlbXBsYXRlIFRcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleFVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleDxUPj59IFByb21pc2UgcmV0dXJuaW5nIEluZGV4IGluc3RhbmNlXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgaW5kZXhVaWQpLmZldGNoSW5mbygpXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2F0aGVyIGluZm9ybWF0aW9uIGFib3V0IGFuIGluZGV4IGJ5IGNhbGxpbmcgTWVpbGlTZWFyY2ggYW5kXHJcbiAgICAgICAgICAgKiByZXR1cm4gdGhlIHJhdyBKU09OIHJlc3BvbnNlXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2V0UmF3SW5kZXhcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleFVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleE9iamVjdD59IFByb21pc2UgcmV0dXJuaW5nIGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0UmF3SW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgaW5kZXhVaWQpLmdldFJhd0luZm8oKV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEdldCBhbGwgdGhlIGluZGV4ZXMgYXMgSW5kZXggaW5zdGFuY2VzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldEluZGV4ZXNcclxuICAgICAgICAgICAqIEBwYXJhbSB7SW5kZXhlc1F1ZXJ5fSBbcGFyYW1ldGVycz17fV0gLSBQYXJhbWV0ZXJzIHRvIGJyb3dzZSB0aGUgaW5kZXhlc1xyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4ZXNSZXN1bHRzPEluZGV4W10+Pn0gUHJvbWlzZSByZXR1cm5pbmcgYXJyYXkgb2YgcmF3IGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJhd0luZGV4ZXMsIGluZGV4ZXM7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuZ2V0UmF3SW5kZXhlcyhwYXJhbWV0ZXJzKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJhd0luZGV4ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMgPSByYXdJbmRleGVzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5kZXgoX3RoaXMuY29uZmlnLCBpbmRleC51aWQsIGluZGV4LnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9fYXNzaWduKF9fYXNzaWduKHt9LCByYXdJbmRleGVzKSwge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IGFsbCB0aGUgaW5kZXhlcyBpbiB0aGVpciByYXcgdmFsdWUgKG5vIEluZGV4IGluc3RhbmNlcykuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2V0UmF3SW5kZXhlc1xyXG4gICAgICAgICAgICogQHBhcmFtIHtJbmRleGVzUXVlcnl9IFtwYXJhbWV0ZXJzPXt9XSAtIFBhcmFtZXRlcnMgdG8gYnJvd3NlIHRoZSBpbmRleGVzXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8SW5kZXhlc1Jlc3VsdHM8SW5kZXhPYmplY3RbXT4+fSBQcm9taXNlIHJldHVybmluZyBhcnJheSBvZiByYXcgaW5kZXggaW5mb3JtYXRpb25cclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5nZXRSYXdJbmRleGVzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsLCBwYXJhbWV0ZXJzKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQ3JlYXRlIGEgbmV3IGluZGV4XHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgY3JlYXRlSW5kZXhcclxuICAgICAgICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpbmRleCBVSURcclxuICAgICAgICAgICAqIEBwYXJhbSB7SW5kZXhPcHRpb25zfSBvcHRpb25zIEluZGV4IG9wdGlvbnNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4PFQ+Pn0gUHJvbWlzZSByZXR1cm5pbmcgSW5kZXggaW5zdGFuY2VcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVJbmRleCA9IGZ1bmN0aW9uICh1aWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCBJbmRleC5jcmVhdGUodWlkLCBvcHRpb25zLCB0aGlzLmNvbmZpZyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFVwZGF0ZSBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZUluZGV4XHJcbiAgICAgICAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0luZGV4T3B0aW9uc30gb3B0aW9ucyBJbmRleCBvcHRpb25zIHRvIHVwZGF0ZVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8SW5kZXg8VD4+fSBQcm9taXNlIHJldHVybmluZyBJbmRleCBpbnN0YW5jZSBhZnRlciB1cGRhdGluZ1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLnVwZGF0ZUluZGV4ID0gZnVuY3Rpb24gKHVpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgdWlkKS51cGRhdGUob3B0aW9ucyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIERlbGV0ZSBhbiBpbmRleFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGRlbGV0ZUluZGV4XHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpbmRleCBVSURcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gaW5kZXggaXMgZGVsZXRlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5kZWxldGVJbmRleCA9IGZ1bmN0aW9uICh1aWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgbmV3IEluZGV4KHRoaXMuY29uZmlnLCB1aWQpW1wiZGVsZXRlXCJdKCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIERlbGV0ZXMgYW4gaW5kZXggaWYgaXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgZGVsZXRlSW5kZXhJZkV4aXN0c1xyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0cnVlIHdoZW4gaW5kZXggZXhpc3RzIGFuZCBpcyBkZWxldGVkIHN1Y2Nlc3NmdWxseSwgb3RoZXJ3aXNlIGZhbHNlIGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZGVsZXRlSW5kZXhJZkV4aXN0cyA9IGZ1bmN0aW9uICh1aWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGVfMTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCwgM10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmRlbGV0ZUluZGV4KHVpZCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xLmNvZGUgPT09IFwiaW5kZXhfbm90X2ZvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgLyogSU5ERVhfTk9UX0ZPVU5EICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogU3dhcHMgYSBsaXN0IG9mIGluZGV4IHR1cGxlcy5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2Qgc3dhcEluZGV4ZXNcclxuICAgICAgICAgICAqIEBwYXJhbSB7U3dhcEluZGV4ZXNQYXJhbXN9IHBhcmFtcyAtIExpc3Qgb2YgaW5kZXhlcyB0dXBsZXMgdG8gc3dhcC5cclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IC0gUHJvbWlzZSByZXR1cm5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuc3dhcEluZGV4ZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICcvc3dhcC1pbmRleGVzJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLy9cbiAgICAgICAgICAvLy8gVEFTS1NcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCBjbGllbnQgdGFza3NcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRUYXNrc1xyXG4gICAgICAgICAgICogQHBhcmFtIHtUYXNrc1F1ZXJ5fSBbcGFyYW1ldGVycz17fV0gLSBQYXJhbWV0ZXJzIHRvIGJyb3dzZSB0aGUgdGFza3NcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrc1Jlc3VsdHM+fSAtIFByb21pc2UgcmV0dXJuaW5nIGFsbCB0YXNrc1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLmdldFRhc2tzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldFRhc2tzKHBhcmFtZXRlcnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgb25lIHRhc2sgb24gdGhlIGNsaWVudCBzY29wZVxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldFRhc2tcclxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXNrVWlkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gLSBQcm9taXNlIHJldHVybmluZyBhIHRhc2tcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5nZXRUYXNrID0gZnVuY3Rpb24gKHRhc2tVaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy50YXNrcy5nZXRUYXNrKHRhc2tVaWQpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBXYWl0IGZvciBtdWx0aXBsZSB0YXNrcyB0byBiZSBmaW5pc2hlZC5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2Qgd2FpdEZvclRhc2tzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0YXNrVWlkcyAtIFRhc2tzIGlkZW50aWZpZXJcclxuICAgICAgICAgICAqIEBwYXJhbSB7V2FpdE9wdGlvbnN9IHdhaXRPcHRpb25zIC0gT3B0aW9ucyBvbiB0aW1lb3V0IGFuZCBpbnRlcnZhbFxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2tbXT59IC0gUHJvbWlzZSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFza3MgPSBmdW5jdGlvbiAodGFza1VpZHMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSxcbiAgICAgICAgICAgICAgX2MgPSBfYi50aW1lT3V0TXMsXG4gICAgICAgICAgICAgIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsXG4gICAgICAgICAgICAgIF9kID0gX2IuaW50ZXJ2YWxNcyxcbiAgICAgICAgICAgICAgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLnRhc2tzLndhaXRGb3JUYXNrcyh0YXNrVWlkcywge1xuICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsTXM6IGludGVydmFsTXNcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFdhaXQgZm9yIGEgdGFzayB0byBiZSBmaW5pc2hlZC5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2Qgd2FpdEZvclRhc2tcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFza1VpZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICAgICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VGFzaz59IC0gUHJvbWlzZSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFzayA9IGZ1bmN0aW9uICh0YXNrVWlkLCBfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsXG4gICAgICAgICAgICAgIF9jID0gX2IudGltZU91dE1zLFxuICAgICAgICAgICAgICB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLFxuICAgICAgICAgICAgICBfZCA9IF9iLmludGVydmFsTXMsXG4gICAgICAgICAgICAgIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy50YXNrcy53YWl0Rm9yVGFzayh0YXNrVWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfZS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQ2FuY2VsIGEgbGlzdCBvZiBlbnF1ZXVlZCBvciBwcm9jZXNzaW5nIHRhc2tzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGNhbmNlbFRhc2tzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0NhbmNlbFRhc2tzUXVlcnl9IFtwYXJhbWV0ZXJzPXt9XSAtIFBhcmFtZXRlcnMgdG8gZmlsdGVyIHRoZSB0YXNrcy5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuY2FuY2VsVGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmNhbmNlbFRhc2tzKHBhcmFtZXRlcnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBEZWxldGUgYSBsaXN0IG9mIHRhc2tzLlxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGRlbGV0ZVRhc2tzXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0RlbGV0ZVRhc2tzUXVlcnl9IFtwYXJhbWV0ZXJzPXt9XSAtIFBhcmFtZXRlcnMgdG8gZmlsdGVyIHRoZSB0YXNrcy5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZGVsZXRlVGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMudGFza3MuZGVsZXRlVGFza3MocGFyYW1ldGVycyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8vXG4gICAgICAgICAgLy8vIEtFWVNcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IGFsbCBBUEkga2V5c1xyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldEtleXNcclxuICAgICAgICAgICAqIEBwYXJhbSB7S2V5c1F1ZXJ5fSBbcGFyYW1ldGVycz17fV0gLSBQYXJhbWV0ZXJzIHRvIGJyb3dzZSB0aGUgaW5kZXhlc1xyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEtleXNSZXN1bHRzPn0gUHJvbWlzZSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGgga2V5c1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIGtleXM7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5c1wiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwsIHBhcmFtZXRlcnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5yZXN1bHRzID0ga2V5cy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBrZXkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGtleS5jcmVhdGVkQXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQXQ6IG5ldyBEYXRlKGtleS51cGRhdGVBdClcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBrZXlzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEdldCBvbmUgQVBJIGtleVxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGdldEtleVxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlPclVpZCAtIEtleSBvciB1aWQgb2YgdGhlIEFQSSBrZXlcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEtleT59IFByb21pc2UgcmV0dXJuaW5nIGEga2V5XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGtleU9yVWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5T3JVaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBDcmVhdGUgb25lIEFQSSBrZXlcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAgICogQG1ldGhvZCBjcmVhdGVLZXlcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0tleUNyZWF0aW9ufSBvcHRpb25zIC0gS2V5IG9wdGlvbnNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEtleT59IFByb21pc2UgcmV0dXJuaW5nIGEga2V5XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlS2V5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBVcGRhdGUgb25lIEFQSSBrZXlcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVLZXlcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5T3JVaWQgLSBLZXlcclxuICAgICAgICAgICAqIEBwYXJhbSB7S2V5VXBkYXRlfSBvcHRpb25zIC0gS2V5IG9wdGlvbnNcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEtleT59IFByb21pc2UgcmV0dXJuaW5nIGEga2V5XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUudXBkYXRlS2V5ID0gZnVuY3Rpb24gKGtleU9yVWlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5T3JVaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBhdGNoKHVybCwgb3B0aW9ucyldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIERlbGV0ZSBvbmUgQVBJIGtleVxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGRlbGV0ZUtleVxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlPclVpZCAtIEtleVxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Vm9pZD59XHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuZGVsZXRlS2V5ID0gZnVuY3Rpb24gKGtleU9yVWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5T3JVaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8vXG4gICAgICAgICAgLy8vIEhFQUxUSFxuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHNlcnZlciBpcyBoZWFsdGh5LCBvdGhlcndpc2UgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgaGVhbHRoXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIZWFsdGg+fSBQcm9taXNlIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBoZWFsdGggZGV0YWlsc1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLmhlYWx0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJoZWFsdGhcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBzZXJ2ZXIgaXMgaGVhbHRoeSwgcmV0dXJuIHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgaXNIZWFsdGh5XHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUHJvbWlzZSByZXR1cm5pbmcgYSBib29sZWFuXHJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIENsaWVudC5wcm90b3R5cGUuaXNIZWFsdGh5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaGVhbHRoXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMlxuICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBTVEFUU1xuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBHZXQgdGhlIHN0YXRzIG9mIGFsbCB0aGUgZGF0YWJhc2VcclxuICAgICAgICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICAgICAgICogQG1ldGhvZCBnZXRTdGF0c1xyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHM+fSBQcm9taXNlIHJldHVybmluZyBvYmplY3Qgb2YgYWxsIHRoZSBzdGF0c1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInN0YXRzXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNFxuICAgICAgICAgICAgICAgICAgICAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8vXG4gICAgICAgICAgLy8vIFZFUlNJT05cbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2V0VmVyc2lvblxyXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VmVyc2lvbj59IFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCB3aXRoIHZlcnNpb24gZGV0YWlsc1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLmdldFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwidmVyc2lvblwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAgICAgICAgICAgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBEVU1QU1xuICAgICAgICAgIC8vL1xuXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBDcmVhdGVzIGEgZHVtcFxyXG4gICAgICAgICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZUR1bXBcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdGFza1xyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZUR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiZHVtcHNcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0XG4gICAgICAgICAgICAgICAgICAgIC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgICAgICAgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vL1xuICAgICAgICAgIC8vLyBUT0tFTlNcbiAgICAgICAgICAvLy9cblxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogR2VuZXJhdGUgYSB0ZW5hbnQgdG9rZW5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAgICAgICAqIEBtZXRob2QgZ2VuZXJhdGVUZW5hbnRUb2tlblxyXG4gICAgICAgICAgICogQHBhcmFtIHthcGlLZXlVaWR9IGFwaUtleVVpZCBUaGUgdWlkIG9mIHRoZSBhcGkga2V5IHVzZWQgYXMgaXNzdWVyIG9mIHRoZSB0b2tlbi5cclxuICAgICAgICAgICAqIEBwYXJhbSB7U2VhcmNoUnVsZXN9IHNlYXJjaFJ1bGVzIFNlYXJjaCBydWxlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IHNlYXJjaC5cclxuICAgICAgICAgICAqIEBwYXJhbSB7VG9rZW5PcHRpb25zfSBvcHRpb25zIFRva2VuIG9wdGlvbnMgdG8gY3VzdG9taXplIHNvbWUgYXNwZWN0IG9mIHRoZSB0b2tlbi5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5nZW5lcmF0ZVRlbmFudFRva2VuID0gZnVuY3Rpb24gKF9hcGlLZXlVaWQsIF9zZWFyY2hSdWxlcywgX29wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVpbGlzZWFyY2g6IGZhaWxlZCB0byBnZW5lcmF0ZSBhIHRlbmFudCB0b2tlbi4gR2VuZXJhdGlvbiBvZiBhIHRva2VuIG9ubHkgd29ya3MgaW4gYSBub2RlIGVudmlyb25tZW50IFxcbiBcIi5jb25jYXQoZXJyb3Iuc3RhY2ssIFwiLlwiKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gQ2xpZW50O1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBNZWlsaVNlYXJjaCA9IC8qKiBAY2xhc3MgKi9cbiAgICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgIF9fZXh0ZW5kcyhNZWlsaVNlYXJjaCwgX3N1cGVyKTtcbiAgICAgICAgICBmdW5jdGlvbiBNZWlsaVNlYXJjaChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNZWlsaVNlYXJjaDtcbiAgICAgICAgfShDbGllbnQpO1xuICAgICAgICBleHBvcnRzLkluZGV4ID0gSW5kZXg7XG4gICAgICAgIGV4cG9ydHMuTWF0Y2hpbmdTdHJhdGVnaWVzID0gTWF0Y2hpbmdTdHJhdGVnaWVzO1xuICAgICAgICBleHBvcnRzLk1laWxpU2VhcmNoID0gTWVpbGlTZWFyY2g7XG4gICAgICAgIGV4cG9ydHMuTWVpbGlTZWFyY2hBcGlFcnJvciA9IE1laWxpU2VhcmNoQXBpRXJyb3I7XG4gICAgICAgIGV4cG9ydHMuTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IgPSBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcjtcbiAgICAgICAgZXhwb3J0cy5NZWlsaVNlYXJjaEVycm9yID0gTWVpbGlTZWFyY2hFcnJvcjtcbiAgICAgICAgZXhwb3J0cy5NZWlsaVNlYXJjaFRpbWVPdXRFcnJvciA9IE1laWxpU2VhcmNoVGltZU91dEVycm9yO1xuICAgICAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1laWxpU2VhcmNoO1xuICAgICAgICBleHBvcnRzLmh0dHBFcnJvckhhbmRsZXIgPSBodHRwRXJyb3JIYW5kbGVyO1xuICAgICAgICBleHBvcnRzLmh0dHBSZXNwb25zZUVycm9ySGFuZGxlciA9IGh0dHBSZXNwb25zZUVycm9ySGFuZGxlcjtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVtb3ZlVW5kZWZpbmVkID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSB1bmRlZmluZWQ7IH0pO1xyXG4gICAgfTtcblxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7YW55fSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZmlsdGVyXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihmaWx0ZXIpIHtcclxuICAgICAgICAvLyB3aWxsIG9ubHkgY2hhbmdlIGZpcnN0IG9jY3VyZW5jZSBvZiBgOmBcclxuICAgICAgICByZXR1cm4gZmlsdGVyLnJlcGxhY2UoLzooLiopL2ksICc9XCIkMVwiJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge2FueVtdfSBhcnJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFycikge1xyXG4gICAgICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhY2MgKz0gSlNPTi5zdHJpbmdpZnkoY3VycikpO1xyXG4gICAgICAgIH0sICcnKTtcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHVyZU9iamVjdChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhICE9PSBudWxsO1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBhcGlLZXkgY2FsbGJhY2sgZGVmaW5pdGlvblxyXG4gICAgICogQGNhbGxiYWNrIGFwaUtleUNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBhcGlLZXkgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIGhvc3QgYW5kIGFwaUtleSBwYXJhbWV0ZXJzLCB0aHJvd3MgaWYgaW52YWxpZFxyXG4gICAgICogQHBhcmFtIGhvc3RVcmxcclxuICAgICAqIEBwYXJhbSBhcGlLZXlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW50TWVpbGlTZWFyY2hQYXJhbXMoaG9zdFVybCwgYXBpS2V5KSB7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgaG9zdCB1cmxcclxuICAgICAgICBpZiAodHlwZW9mIGhvc3RVcmwgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIGhvc3RVcmwgdmFsdWUgKDFzdCBwYXJhbWV0ZXIpIGlzIG5vdCBhIHN0cmluZywgZXhwZWN0ZWQgc3RyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFZhbGlkYXRlIGFwaSBrZXlcclxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBhcGlLZXkgdmFsdWUgKDJuZCBwYXJhbWV0ZXIpIGlzIG5vdCBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLCBleHBlY3RlZCBzdHJpbmcgb3IgZnVuY3Rpb24nKTtcclxuICAgICAgICB9XHJcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZmlsdGVyXHJcbiAgICAgKi9cclxuICAgIHZhciBhZGFwdEZpbHRlclN5bnRheCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZpbHRlci5tYXRjaCgvKFtePV0qKT1cIj8oW15cXFxcXCJdKilcIj8kLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgbWF0Y2hlc1swXTsgdmFyIGZpbHRlck5hbWUgPSBtYXRjaGVzWzFdLCB2YWx1ZSA9IG1hdGNoZXNbMl07XHJcbiAgICAgICAgICAgIHJldHVybiBbeyBmaWx0ZXJOYW1lOiBmaWx0ZXJOYW1lLCB2YWx1ZTogdmFsdWUgfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge0ZpbHRlcn0gZmlsdGVycz9cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZpbHRlcnMoZmlsdGVycykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0RmlsdGVyU3ludGF4KGZpbHRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJzXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuZXN0ZWRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5lc3RlZEZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVzdGVkRmlsdGVyLm1hcChmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBhZGFwdEZpbHRlclN5bnRheChmaWx0ZXIpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdEZpbHRlclN5bnRheChuZXN0ZWRGaWx0ZXIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZsYXQoMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7RmlsdGVyfSBmaWx0ZXJzP1xyXG4gICAgICogQHJldHVybnMge0ZhY2V0c0NhY2hlfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRGYWNldHNGcm9tRmlsdGVyKGZpbHRlcnMpIHtcclxuICAgICAgICB2YXIgZXh0cmFjdGVkRmlsdGVycyA9IGV4dHJhY3RGaWx0ZXJzKGZpbHRlcnMpO1xyXG4gICAgICAgIHZhciBjbGVhbkZpbHRlcnMgPSByZW1vdmVVbmRlZmluZWQoZXh0cmFjdGVkRmlsdGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFuRmlsdGVycy5yZWR1Y2UoZnVuY3Rpb24gKGNhY2hlLCBwYXJzZWRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyTmFtZSA9IHBhcnNlZEZpbHRlci5maWx0ZXJOYW1lLCB2YWx1ZSA9IHBhcnNlZEZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHByZXZGaWVsZHMgPSBjYWNoZVtmaWx0ZXJOYW1lXSB8fCBbXTtcclxuICAgICAgICAgICAgY2FjaGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2FjaGUpLCAoX2EgPSB7fSwgX2FbZmlsdGVyTmFtZV0gPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXZGaWVsZHMsIHRydWUpLCBbdmFsdWVdLCBmYWxzZSksIF9hKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRGYWNldHNGcm9tRGVmYXVsdERpc3RyaWJ1dGlvbihmYWNldERpc3RyaWJ1dGlvbikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmYWNldERpc3RyaWJ1dGlvbikucmVkdWNlKGZ1bmN0aW9uIChjYWNoZSwgZmFjZXQpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgZmFjZXRWYWx1ZXMgPSBPYmplY3Qua2V5cyhmYWNldERpc3RyaWJ1dGlvbltmYWNldF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGNhY2hlKSwgKF9hID0ge30sIF9hW2ZhY2V0XSA9IGZhY2V0VmFsdWVzLCBfYSkpO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7RmlsdGVyfSBmaWx0ZXJzP1xyXG4gICAgICogQHJldHVybnMge0ZhY2V0c0NhY2hlfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHRyYWN0RmFjZXRzKHNlYXJjaENvbnRleHQsIHNlYXJjaFBhcmFtcykge1xyXG4gICAgICAgIGlmIChzZWFyY2hDb250ZXh0LmtlZXBaZXJvRmFjZXRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRGYWNldHNGcm9tRGVmYXVsdERpc3RyaWJ1dGlvbihzZWFyY2hDb250ZXh0LmRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0RmFjZXRzRnJvbUZpbHRlcihzZWFyY2hQYXJhbXMgPT09IG51bGwgfHwgc2VhcmNoUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hQYXJhbXMuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFzc2lnbiBtaXNzaW5nIGZpbHRlcnMgdG8gZmFjZXREaXN0cmlidXRpb24uXHJcbiAgICAgKiBBbGwgZmFjZXRzIHBhc3NlZCBhcyBmaWx0ZXIgc2hvdWxkIGFwcGVhciBpbiB0aGUgZmFjZXREaXN0cmlidXRpb24uXHJcbiAgICAgKiBJZiBub3QgcHJlc2VudCwgdGhlIGZhY2V0IGlzIGFkZGVkIHdpdGggMCBhcyB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7RmFjZXRzQ2FjaGV9IGNhY2hlP1xyXG4gICAgICogQHBhcmFtICB7RmFjZXREaXN0cmlidXRpb259IGRpc3RyaWJ1dGlvbj9cclxuICAgICAqIEByZXR1cm5zIHtGYWNldERpc3RyaWJ1dGlvbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkTWlzc2luZ0ZhY2V0cyhjYWNoZWRGYWNldHMsIGRpc3RyaWJ1dGlvbikge1xyXG4gICAgICAgIGRpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvbiB8fCB7fTtcclxuICAgICAgICAvLyBJZiBjYWNoZWRGYWNldHMgY29udGFpbnMgc29tZXRoaW5nXHJcbiAgICAgICAgaWYgKGNhY2hlZEZhY2V0cyAmJiBPYmplY3Qua2V5cyhjYWNoZWRGYWNldHMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gZm9yIGFsbCBmaWx0ZXJzIGluIGNhY2hlZCBmaWx0ZXJzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGNhY2hlZEZhY2V0IGluIGNhY2hlZEZhY2V0cykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgZmFjZXQgZG9lcyBub3QgZXhpc3Qgb24gcmV0dXJuZWQgZGlzdHJpYnV0aW9uLCBhZGQgYW4gZW1wdHkgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3RyaWJ1dGlvbltjYWNoZWRGYWNldF0pXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2NhY2hlZEZhY2V0XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGFsbCBmaWVsZHMgaW4gZXZlcnkgZmlsdGVyXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY2FjaGVkRmFjZXRzW2NhY2hlZEZhY2V0XTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkRmllbGQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZXR1cm5lZCBkaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaXQgYXQgMFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZGlzdHJpYnV0aW9uW2NhY2hlZEZhY2V0XSkuaW5jbHVkZXMoY2FjaGVkRmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCAwIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltjYWNoZWRGYWNldF1bY2FjaGVkRmllbGRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcclxuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7UmVzcG9uc2VDYWNoZXJ9IGNhY2hlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNlYXJjaFJlc29sdmVyKGNsaWVudCwgY2FjaGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtICB7U2VhcmNoQ29udGV4dH0gc2VhcmNoQ29udGV4dFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtNZWlsaVNlYXJjaFBhcmFtc30gc2VhcmNoUGFyYW1zXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge01laWxpU2VhcmNofSBjbGllbnRcclxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZWFyY2hSZXNwb25zZTogZnVuY3Rpb24gKHNlYXJjaENvbnRleHQsIHNlYXJjaFBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlclNlYXJjaCwgcXVlcnksIGtleSwgY2FjaGVkUmVzcG9uc2UsIGNhY2hlZEZhY2V0cywgc2VhcmNoUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJTZWFyY2ggPSBzZWFyY2hDb250ZXh0LnBsYWNlaG9sZGVyU2VhcmNoLCBxdWVyeSA9IHNlYXJjaENvbnRleHQucXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FjaGUuZm9ybWF0S2V5KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0LmluZGV4VWlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0LnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0LnBhZ2luYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBjYWNoZS5nZXRFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHNwZWNpZmljIHJlcXVlc3QgaXMgYWxyZWFkeSBjYWNoZWQgd2l0aCBpdHMgYXNzb2NpYXRlZCBzZWFyY2ggcmVzcG9uc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkUmVzcG9uc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEZhY2V0cyA9IGV4dHJhY3RGYWNldHMoc2VhcmNoQ29udGV4dCwgc2VhcmNoUGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleChzZWFyY2hDb250ZXh0LmluZGV4VWlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlYXJjaChzZWFyY2hDb250ZXh0LnF1ZXJ5LCBzZWFyY2hQYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIGZhY2V0cyBiYWNrIGludG8gZmFjZXREaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIGZhY2V0cyBiYWNrIGludG8gZmFjZXREaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZS5mYWNldERpc3RyaWJ1dGlvbiA9IGFkZE1pc3NpbmdGYWNldHMoY2FjaGVkRmFjZXRzLCBzZWFyY2hSZXNwb25zZS5mYWNldERpc3RyaWJ1dGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgY2FuIGJlOiBlbXB0eSBzdHJpbmcsIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZW0gYXJlIGZhbHN5J3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBsYWNlaG9sZGVyU2VhcmNoICYmICFxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZS5oaXRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0RW50cnkoa2V5LCBzZWFyY2hSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlYXJjaFJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJhZFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmFkMmRlZ3IocmFkKSB7XHJcbiAgICAgICAgcmV0dXJuIChyYWQgKiAxODApIC8gTWF0aC5QSTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBkZWdyXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWdyMnJhZChkZWdyKSB7XHJcbiAgICAgICAgcmV0dXJuIChkZWdyICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gbGF0MVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBsbmcxXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxhdDJcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gbG5nMlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWlkZGxlR2VvUG9pbnRzKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpIHtcclxuICAgICAgICAvLyBjb252ZXJ0IHRvIHJhZGlhbnNcclxuICAgICAgICBsYXQxID0gZGVncjJyYWQobGF0MSk7XHJcbiAgICAgICAgbG5nMSA9IGRlZ3IycmFkKGxuZzEpO1xyXG4gICAgICAgIHZhciB4MSA9IE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobG5nMSk7XHJcbiAgICAgICAgdmFyIHkxID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsbmcxKTtcclxuICAgICAgICB2YXIgejEgPSBNYXRoLnNpbihsYXQxKTtcclxuICAgICAgICAvLyBjb252ZXJ0IHRvIHJhZGlhbnNcclxuICAgICAgICBsYXQyID0gZGVncjJyYWQobGF0Mik7XHJcbiAgICAgICAgbG5nMiA9IGRlZ3IycmFkKGxuZzIpO1xyXG4gICAgICAgIHZhciB4MiA9IE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG5nMik7XHJcbiAgICAgICAgdmFyIHkyID0gTWF0aC5jb3MobGF0MikgKiBNYXRoLnNpbihsbmcyKTtcclxuICAgICAgICB2YXIgejIgPSBNYXRoLnNpbihsYXQyKTtcclxuICAgICAgICB2YXIgeCA9IHgxICsgeDI7XHJcbiAgICAgICAgdmFyIHkgPSB5MSArIHkyO1xyXG4gICAgICAgIHZhciB6ID0gejEgKyB6MjtcclxuICAgICAgICB2YXIgSHlwID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgICAgIHZhciBsbmczID0gTWF0aC5hdGFuMih5LCB4KTtcclxuICAgICAgICB2YXIgbGF0MyA9IE1hdGguYXRhbjIoeiwgSHlwKTtcclxuICAgICAgICBpZiAobG5nMSA8IGxuZzIgfHwgKGxuZzEgPiBsbmcyICYmIGxuZzEgPiBNYXRoLlBJICYmIGxuZzIgPCAtTWF0aC5QSSkpIHtcclxuICAgICAgICAgICAgbGF0MyA9IGxhdDMgKyBNYXRoLlBJO1xyXG4gICAgICAgICAgICBsbmczID0gbG5nMyArIE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsYXQzID0gcmFkMmRlZ3IobGF0Myk7XHJcbiAgICAgICAgICAgIGxuZzMgPSByYWQyZGVncihsbmczKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHgpIDwgTWF0aC5wb3coMTAsIC05KSAmJlxyXG4gICAgICAgICAgICBNYXRoLmFicyh5KSA8IE1hdGgucG93KDEwLCAtOSkgJiZcclxuICAgICAgICAgICAgTWF0aC5hYnMoeikgPCBNYXRoLnBvdygxMCwgLTkpKSB7XHJcbiAgICAgICAgICAgIGxhdDMgPSAwO1xyXG4gICAgICAgICAgICBsbmczID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGxhdDMsIFwiLFwiKS5jb25jYXQobG5nMyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gbGF0MVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBsbmcxXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxhdDJcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gbG5nMlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VJbk1ldGVyKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpIHtcclxuICAgICAgICAvLyBIYXZlcnNpbmUgQWxnb3JpdGhtXHJcbiAgICAgICAgdmFyIFIgPSA2MzcxZTM7IC8vIG1ldHJlc1xyXG4gICAgICAgIHZhciBsYXRSYWQxID0gKGxhdDEgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgICAgICB2YXIgbGF0UmFkMiA9IChsYXQyICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICAgICAgdmFyIGxhdENlbnRlclJhZCA9ICgobGF0MiAtIGxhdDEpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICAgICAgdmFyIGxuZ0NlbnRlclJhZCA9ICgobG5nMiAtIGxuZzEpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICAgICAgdmFyIGEgPSBNYXRoLnNpbihsYXRDZW50ZXJSYWQgLyAyKSAqIE1hdGguc2luKGxhdENlbnRlclJhZCAvIDIpICtcclxuICAgICAgICAgICAgTWF0aC5jb3MobGF0UmFkMSkgKlxyXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MobGF0UmFkMikgKlxyXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4obG5nQ2VudGVyUmFkIC8gMikgKlxyXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4obG5nQ2VudGVyUmFkIC8gMik7XHJcbiAgICAgICAgdmFyIGJlYXJpbmcgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IFIgKiBiZWFyaW5nOyAvLyBpbiBtZXRyZXNcclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGFwdEdlb1BvaW50c1J1bGVzKGdlb1NlYXJjaENvbnRleHQpIHtcclxuICAgICAgICBpZiAoIWdlb1NlYXJjaENvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluc2lkZUJvdW5kaW5nQm94ID0gZ2VvU2VhcmNoQ29udGV4dC5pbnNpZGVCb3VuZGluZ0JveCwgYXJvdW5kTGF0TG5nID0gZ2VvU2VhcmNoQ29udGV4dC5hcm91bmRMYXRMbmcsIGFyb3VuZFJhZGl1cyA9IGdlb1NlYXJjaENvbnRleHQuYXJvdW5kUmFkaXVzLCBtaW5pbXVtQXJvdW5kUmFkaXVzID0gZ2VvU2VhcmNoQ29udGV4dC5taW5pbXVtQXJvdW5kUmFkaXVzO1xyXG4gICAgICAgIHZhciBtaWRkbGVQb2ludDtcclxuICAgICAgICB2YXIgcmFkaXVzO1xyXG4gICAgICAgIGlmIChhcm91bmRMYXRMbmcpIHtcclxuICAgICAgICAgICAgbWlkZGxlUG9pbnQgPSBhcm91bmRMYXRMbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcm91bmRSYWRpdXMgIT0gbnVsbCB8fCBtaW5pbXVtQXJvdW5kUmFkaXVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGFyb3VuZFJhZGl1cyAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gYXJvdW5kUmFkaXVzO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBtaW5pbXVtQXJvdW5kUmFkaXVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBpbnNpZGVCb3VuZGluZ0JveCBpcyBwcm92aWRlZCBpdCB0YWtlcyBwcmVjZWRlbnQgb3ZlciBhbGwgb3RoZXIgb3B0aW9uc1xyXG4gICAgICAgIGlmIChpbnNpZGVCb3VuZGluZ0JveCAmJiB0eXBlb2YgaW5zaWRlQm91bmRpbmdCb3ggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGluc2lkZUJvdW5kaW5nQm94LnNwbGl0KCcsJyksIGxhdDFSYXcgPSBfYVswXSwgbG5nMVJhdyA9IF9hWzFdLCBsYXQyUmF3ID0gX2FbMl0sIGxuZzJSYXcgPSBfYVszXTtcclxuICAgICAgICAgICAgdmFyIF9iID0gW1xyXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChsYXQxUmF3KSxcclxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobG5nMVJhdyksXHJcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGxhdDJSYXcpLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChsbmcyUmF3KSxcclxuICAgICAgICAgICAgXSwgbGF0MSA9IF9iWzBdLCBsbmcxID0gX2JbMV0sIGxhdDIgPSBfYlsyXSwgbG5nMiA9IF9iWzNdO1xyXG4gICAgICAgICAgICByYWRpdXMgPSBnZXREaXN0YW5jZUluTWV0ZXIobGF0MSwgbG5nMSwgbGF0MiwgbG5nMikgLyAyO1xyXG4gICAgICAgICAgICBtaWRkbGVQb2ludCA9IG1pZGRsZUdlb1BvaW50cyhsYXQxLCBsbmcxLCBsYXQyLCBsbmcyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pZGRsZVBvaW50ICE9IG51bGwgJiYgcmFkaXVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIF9jID0gbWlkZGxlUG9pbnQuc3BsaXQoJywnKSwgbGF0MyA9IF9jWzBdLCBsbmczID0gX2NbMV07XHJcbiAgICAgICAgICAgIGxhdDMgPSBOdW1iZXIucGFyc2VGbG9hdChsYXQzKS50b0ZpeGVkKDUpO1xyXG4gICAgICAgICAgICBsbmczID0gTnVtYmVyLnBhcnNlRmxvYXQobG5nMykudG9GaXhlZCg1KTtcclxuICAgICAgICAgICAgdmFyIGZpbHRlciA9IFwiX2dlb1JhZGl1cyhcIi5jb25jYXQobGF0MywgXCIsIFwiKS5jb25jYXQobG5nMywgXCIsIFwiKS5jb25jYXQocmFkaXVzLCBcIilcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGZpbHRlcjogZmlsdGVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVHZW9TZWFyY2hDb250ZXh0KHNlYXJjaENvbnRleHQpIHtcclxuICAgICAgICB2YXIgZ2VvQ29udGV4dCA9IHt9O1xyXG4gICAgICAgIHZhciBhcm91bmRMYXRMbmcgPSBzZWFyY2hDb250ZXh0LmFyb3VuZExhdExuZywgYXJvdW5kTGF0TG5nVmlhSVAgPSBzZWFyY2hDb250ZXh0LmFyb3VuZExhdExuZ1ZpYUlQLCBhcm91bmRSYWRpdXMgPSBzZWFyY2hDb250ZXh0LmFyb3VuZFJhZGl1cywgYXJvdW5kUHJlY2lzaW9uID0gc2VhcmNoQ29udGV4dC5hcm91bmRQcmVjaXNpb24sIG1pbmltdW1Bcm91bmRSYWRpdXMgPSBzZWFyY2hDb250ZXh0Lm1pbmltdW1Bcm91bmRSYWRpdXMsIGluc2lkZUJvdW5kaW5nQm94ID0gc2VhcmNoQ29udGV4dC5pbnNpZGVCb3VuZGluZ0JveCwgaW5zaWRlUG9seWdvbiA9IHNlYXJjaENvbnRleHQuaW5zaWRlUG9seWdvbjtcclxuICAgICAgICBpZiAoYXJvdW5kTGF0TG5nKSB7XHJcbiAgICAgICAgICAgIGdlb0NvbnRleHQuYXJvdW5kTGF0TG5nID0gYXJvdW5kTGF0TG5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJvdW5kTGF0TG5nVmlhSVApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdpbnN0YW50LW1laWxpc2VhcmNoOiBgYXJvdW5kTGF0TG5nVmlhSVBgIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcm91bmRSYWRpdXMpIHtcclxuICAgICAgICAgICAgZ2VvQ29udGV4dC5hcm91bmRSYWRpdXMgPSBhcm91bmRSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcm91bmRQcmVjaXNpb24pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiaW5zdGFudC1tZWlsaXNlYXJjaDogYGFyb3VuZFByZWNpc2lvbmAgaXMgbm90IHN1cHBvcnRlZC5cXG4gICAgU2VlIHRoaXMgZGlzY3Vzc2lvbiB0byB0cmFjayBpdHMgaW1wbGVtZW50YXRpb24gaHR0cHM6Ly9naXRodWIuY29tL21laWxpc2VhcmNoL3Byb2R1Y3QvZGlzY3Vzc2lvbnMvMjY0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluaW11bUFyb3VuZFJhZGl1cykge1xyXG4gICAgICAgICAgICBnZW9Db250ZXh0Lm1pbmltdW1Bcm91bmRSYWRpdXMgPSBtaW5pbXVtQXJvdW5kUmFkaXVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zaWRlQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgZ2VvQ29udGV4dC5pbnNpZGVCb3VuZGluZ0JveCA9IGluc2lkZUJvdW5kaW5nQm94O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWUgcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL21laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvaXNzdWVzLzU1NVxyXG4gICAgICAgIGlmIChpbnNpZGVQb2x5Z29uKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImluc3RhbnQtbWVpbGlzZWFyY2g6IGBpbnNpZGVQb2x5Z29uYCBpcyBub3QgaW1wbGVudGVkIGluIGluc3RhbnQtbWVpbGlzZWFyY2guXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2VvQ29udGV4dDtcclxuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIEluc3RhbnRTZWFyY2ggZmlsdGVyIHRvIE1laWxpc2VhcmNoIGZpbHRlci5cclxuICAgICAqIENoYW5nZSBzaWduIGZyb20gYDpgIHRvIGA9YCBpbiBuZXN0ZWQgZmlsdGVyIG9iamVjdC5cclxuICAgICAqIGV4YW1wbGU6IFtgZ2VucmVzOmNvbWVkeWBdIGJlY29tZXMgW2BnZW5yZXM9Y29tZWR5YF1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0WydmYWNldEZpbHRlcnMnXX0gZmlsdGVycz9cclxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZpbHRlcihmaWx0ZXJzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZUNvbG9uQnlFcXVhbFNpZ24oZmlsdGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykpXHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJzXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuZXN0ZWRGaWx0ZXIpIHsgcmV0dXJuIHJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduKG5lc3RlZEZpbHRlcik7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW07IH0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduKGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtOyB9KTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZmlsdGVyIGluIGFuIGFycmF5IGlmIGl0IGlzIGEgc3RyaW5nXHJcbiAgICAgKiBJZiBmaWx0ZXIgaXMgYXJyYXksIHJldHVybiB3aXRob3V0IGNoYW5nZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtGaWx0ZXJ9IGZpbHRlclxyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJUb0FycmF5KGZpbHRlcikge1xyXG4gICAgICAgIC8vIEZpbHRlciBpcyBhIHN0cmluZ1xyXG4gICAgICAgIGlmIChmaWx0ZXIgPT09ICcnKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHJldHVybiBbZmlsdGVyXTtcclxuICAgICAgICAvLyBGaWx0ZXIgaXMgZWl0aGVyIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9yIGFuIGFycmF5IG9mIGFycmF5IG9mIHN0cmluZ3NcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXJnZSBmYWNldEZpbHRlcnMsIG51bWVyaWNGaWx0ZXJzIGFuZCBmaWx0ZXJzIHRvZ2V0aGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge0ZpbHRlcn0gZmFjZXRGaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0gIHtGaWx0ZXJ9IG51bWVyaWNGaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbHRlcnNcclxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1lcmdlRmlsdGVycyhmYWNldEZpbHRlcnMsIG51bWVyaWNGaWx0ZXJzLCBmaWx0ZXJzKSB7XHJcbiAgICAgICAgdmFyIGFkYXB0ZWRGaWx0ZXJzID0gZmlsdGVycy50cmltKCk7XHJcbiAgICAgICAgdmFyIGFkYXB0ZWRGYWNldEZpbHRlcnMgPSBmaWx0ZXJUb0FycmF5KGZhY2V0RmlsdGVycyk7XHJcbiAgICAgICAgdmFyIGFkYXB0ZWROdW1lcmljRmlsdGVycyA9IGZpbHRlclRvQXJyYXkobnVtZXJpY0ZpbHRlcnMpO1xyXG4gICAgICAgIHZhciBhZGFwdGVkRmlsdGVyID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGFkYXB0ZWRGYWNldEZpbHRlcnMsIHRydWUpLCBhZGFwdGVkTnVtZXJpY0ZpbHRlcnMsIHRydWUpLCBbXHJcbiAgICAgICAgICAgIGFkYXB0ZWRGaWx0ZXJzLFxyXG4gICAgICAgIF0sIGZhbHNlKTtcclxuICAgICAgICB2YXIgY2xlYW5lZEZpbHRlcnMgPSBhZGFwdGVkRmlsdGVyLmZpbHRlcihmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFuZWRGaWx0ZXJzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGFwdCBpbnN0YW50c2VhcmNoLmpzIGZpbHRlcnMgdG8gTWVpbGlzZWFyY2ggZmlsdGVycyBieVxyXG4gICAgICogY29tYmluaW5nIGFuZCB0cmFuc2Zvcm1pbmcgYWxsIHByb3ZpZGVkIGZpbHRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfHVuZGVmaW5lZH0gZmlsdGVyc1xyXG4gICAgICogQHBhcmFtICB7U2VhcmNoQ29udGV4dFsnbnVtZXJpY0ZpbHRlcnMnXX0gbnVtZXJpY0ZpbHRlcnNcclxuICAgICAqIEBwYXJhbSAge1NlYXJjaENvbnRleHRbJ2ZhY2V0RmlsdGVycyddfSBmYWNldEZpbHRlcnNcclxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkYXB0RmlsdGVycyhmaWx0ZXJzLCBudW1lcmljRmlsdGVycywgZmFjZXRGaWx0ZXJzKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkRmlsdGVyID0gdHJhbnNmb3JtRmlsdGVyKGZhY2V0RmlsdGVycyB8fCBbXSk7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkTnVtZXJpY0ZpbHRlciA9IHRyYW5zZm9ybUZpbHRlcihudW1lcmljRmlsdGVycyB8fCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRmlsdGVycyh0cmFuc2Zvcm1lZEZpbHRlciwgdHJhbnNmb3JtZWROdW1lcmljRmlsdGVyLCBmaWx0ZXJzIHx8ICcnKTtcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNjcm9sbFBhZ2luYXRpb24oaGl0c1BlclBhZ2UsIHBhZ2UsIHF1ZXJ5LCBwbGFjZWhvbGRlclNlYXJjaCkge1xyXG4gICAgICAgIGlmICghcGxhY2Vob2xkZXJTZWFyY2ggJiYgcXVlcnkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsaW1pdDogMCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW1pdDogaGl0c1BlclBhZ2UgKyAxLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHBhZ2UgKiBoaXRzUGVyUGFnZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRGaW5pdGVQYWdpbmF0aW9uKGhpdHNQZXJQYWdlLCBwYWdlLCBxdWVyeSwgcGxhY2Vob2xkZXJTZWFyY2gpIHtcclxuICAgICAgICBpZiAoIXBsYWNlaG9sZGVyU2VhcmNoICYmIHF1ZXJ5ID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaGl0c1BlclBhZ2U6IDAsXHJcbiAgICAgICAgICAgICAgICBwYWdlOiBwYWdlICsgMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGhpdHNQZXJQYWdlOiBoaXRzUGVyUGFnZSxcclxuICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UgKyAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGFwdHMgaW5zdGFudHNlYXJjaC5qcyBhbmQgaW5zdGFudC1tZWlsaXNlYXJjaCBvcHRpb25zXHJcbiAgICAgKiB0byBtZWlsaXNlYXJjaCBzZWFyY2ggcXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge01laWxpU2VhcmNoUGFyYW1zfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBNZWlsaVBhcmFtc0NyZWF0b3Ioc2VhcmNoQ29udGV4dCkge1xyXG4gICAgICAgIHZhciBtZWlsaVNlYXJjaFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHZhciBmYWNldHMgPSBzZWFyY2hDb250ZXh0LmZhY2V0cywgYXR0cmlidXRlc1RvU25pcHBldCA9IHNlYXJjaENvbnRleHQuYXR0cmlidXRlc1RvU25pcHBldCwgc25pcHBldEVsbGlwc2lzVGV4dCA9IHNlYXJjaENvbnRleHQuc25pcHBldEVsbGlwc2lzVGV4dCwgYXR0cmlidXRlc1RvUmV0cmlldmUgPSBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb1JldHJpZXZlLCBmaWx0ZXJzID0gc2VhcmNoQ29udGV4dC5maWx0ZXJzLCBudW1lcmljRmlsdGVycyA9IHNlYXJjaENvbnRleHQubnVtZXJpY0ZpbHRlcnMsIGZhY2V0RmlsdGVycyA9IHNlYXJjaENvbnRleHQuZmFjZXRGaWx0ZXJzLCBhdHRyaWJ1dGVzVG9IaWdobGlnaHQgPSBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb0hpZ2hsaWdodCwgaGlnaGxpZ2h0UHJlVGFnID0gc2VhcmNoQ29udGV4dC5oaWdobGlnaHRQcmVUYWcsIGhpZ2hsaWdodFBvc3RUYWcgPSBzZWFyY2hDb250ZXh0LmhpZ2hsaWdodFBvc3RUYWcsIHBsYWNlaG9sZGVyU2VhcmNoID0gc2VhcmNoQ29udGV4dC5wbGFjZWhvbGRlclNlYXJjaCwgcXVlcnkgPSBzZWFyY2hDb250ZXh0LnF1ZXJ5LCBzb3J0ID0gc2VhcmNoQ29udGV4dC5zb3J0LCBwYWdpbmF0aW9uID0gc2VhcmNoQ29udGV4dC5wYWdpbmF0aW9uLCBtYXRjaGluZ1N0cmF0ZWd5ID0gc2VhcmNoQ29udGV4dC5tYXRjaGluZ1N0cmF0ZWd5O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldFBhcmFtczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1laWxpU2VhcmNoUGFyYW1zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRGYWNldHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmYWNldHMgPT09IG51bGwgfHwgZmFjZXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWNldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuZmFjZXRzID0gZmFjZXRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRBdHRyaWJ1dGVzVG9Dcm9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1RvU25pcHBldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb0Nyb3AgPSBhdHRyaWJ1dGVzVG9TbmlwcGV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRDcm9wTWFya2VyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIFRvIENyb3AgbWFya2VyXHJcbiAgICAgICAgICAgICAgICBpZiAoc25pcHBldEVsbGlwc2lzVGV4dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuY3JvcE1hcmtlciA9IHNuaXBwZXRFbGxpcHNpc1RleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFkZEF0dHJpYnV0ZXNUb1JldHJpZXZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1RvUmV0cmlldmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5hdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9IGF0dHJpYnV0ZXNUb1JldHJpZXZlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRGaWx0ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gYWRhcHRGaWx0ZXJzKGZpbHRlcnMsIG51bWVyaWNGaWx0ZXJzLCBmYWNldEZpbHRlcnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFkZEF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuYXR0cmlidXRlc1RvSGlnaGxpZ2h0ID0gYXR0cmlidXRlc1RvSGlnaGxpZ2h0IHx8IFsnKiddO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRQcmVUYWc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRQcmVUYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQcmVUYWcgPSBoaWdobGlnaHRQcmVUYWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQcmVUYWcgPSAnX19haXMtaGlnaGxpZ2h0X18nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRQb3N0VGFnOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UG9zdFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmhpZ2hsaWdodFBvc3RUYWcgPSBoaWdobGlnaHRQb3N0VGFnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuaGlnaGxpZ2h0UG9zdFRhZyA9ICdfXy9haXMtaGlnaGxpZ2h0X18nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRQYWdpbmF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnaW5hdGlvbi5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBzZXRGaW5pdGVQYWdpbmF0aW9uKHBhZ2luYXRpb24uaGl0c1BlclBhZ2UsIHBhZ2luYXRpb24ucGFnZSwgcXVlcnksIHBsYWNlaG9sZGVyU2VhcmNoKSwgaGl0c1BlclBhZ2UgPSBfYS5oaXRzUGVyUGFnZSwgcGFnZSA9IF9hLnBhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuaGl0c1BlclBhZ2UgPSBoaXRzUGVyUGFnZTtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5wYWdlID0gcGFnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IHNldFNjcm9sbFBhZ2luYXRpb24ocGFnaW5hdGlvbi5oaXRzUGVyUGFnZSwgcGFnaW5hdGlvbi5wYWdlLCBxdWVyeSwgcGxhY2Vob2xkZXJTZWFyY2gpLCBsaW1pdCA9IF9iLmxpbWl0LCBvZmZzZXQgPSBfYi5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFkZFNvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3J0ID09PSBudWxsIHx8IHNvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvcnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuc29ydCA9IFtzb3J0XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWRkR2VvU2VhcmNoUnVsZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnZW9TZWFyY2hDb250ZXh0ID0gY3JlYXRlR2VvU2VhcmNoQ29udGV4dChzZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHZhciBnZW9SdWxlcyA9IGFkYXB0R2VvUG9pbnRzUnVsZXMoZ2VvU2VhcmNoQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VvUnVsZXMgPT09IG51bGwgfHwgZ2VvUnVsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlb1J1bGVzLmZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWlsaVNlYXJjaFBhcmFtcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuZmlsdGVyLnVuc2hpZnQoZ2VvUnVsZXMuZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmZpbHRlciA9IFtnZW9SdWxlcy5maWx0ZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWRkTWF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5tYXRjaGluZ1N0cmF0ZWd5ID0gbWF0Y2hpbmdTdHJhdGVneTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkYXB0IHNlYXJjaCByZXF1ZXN0IGZyb20gaW5zdGFudHNlYXJjaC5qc1xyXG4gICAgICogdG8gc2VhcmNoIHJlcXVlc3QgY29tcGxpYW50IHdpdGggTWVpbGlzZWFyY2hcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7TWVpbGlTZWFyY2hQYXJhbXN9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkYXB0U2VhcmNoUGFyYW1zKHNlYXJjaENvbnRleHQpIHtcclxuICAgICAgICB2YXIgbWVpbGlzZWFyY2hQYXJhbXMgPSBNZWlsaVBhcmFtc0NyZWF0b3Ioc2VhcmNoQ29udGV4dCk7XHJcbiAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkRmFjZXRzKCk7XHJcbiAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkQXR0cmlidXRlc1RvSGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkUHJlVGFnKCk7XHJcbiAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkUG9zdFRhZygpO1xyXG4gICAgICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZEF0dHJpYnV0ZXNUb1JldHJpZXZlKCk7XHJcbiAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkQXR0cmlidXRlc1RvQ3JvcCgpO1xyXG4gICAgICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZENyb3BNYXJrZXIoKTtcclxuICAgICAgICBtZWlsaXNlYXJjaFBhcmFtcy5hZGRQYWdpbmF0aW9uKCk7XHJcbiAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkRmlsdGVycygpO1xyXG4gICAgICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZFNvcnQoKTtcclxuICAgICAgICBtZWlsaXNlYXJjaFBhcmFtcy5hZGRHZW9TZWFyY2hSdWxlcygpO1xyXG4gICAgICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZE1hdGNoaW5nU3RyYXRlZ3koKTtcclxuICAgICAgICByZXR1cm4gbWVpbGlzZWFyY2hQYXJhbXMuZ2V0UGFyYW1zKCk7XHJcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIFN0cmluZ2lmeSB2YWx1ZXMgZm9sbG93aW5nIGluc3RhbnRzZWFyY2ggcHJhY3RpY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge2FueX0gdmFsdWUgLSB2YWx1ZSB0aGF0IG5lZWRzIHRvIGJlIHN0cmluZ2lmaWVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gU3RyaW5nXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyB1bmRlZmluZWRcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2lmIGZ1bmN0aW9uIHdyYXAgdGhlIGRlZXBlc3QgcG9zc2libGUgdmFsdWVcclxuICAgICAqIHRoZSBmb2xsb3dpbmcgd2F5OiB7IHZhbHVlOiBcInh4XCIgfS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZTpcclxuICAgICAqXHJcbiAgICAgKiB7XHJcbiAgICAgKiBcInJvb3RGaWVsZFwiOiB7IFwidmFsdWVcIjogXCJ4XCIgfVxyXG4gICAgICogXCJuZXN0ZWRGaWVsZFwiOiB7IGNoaWxkOiB7IHZhbHVlOiBcInlcIiB9IH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiByZWN1cnNpdml0eSBjb250aW51ZXMgdW50aWwgdGhlIHZhbHVlIGlzIG5vdCBhbiBhcnJheSBvciBhbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7YW55fSB2YWx1ZSAtIHZhbHVlIG9mIGEgZmllbGRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdyYXBWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAvLyBBcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB3cmFwVmFsdWUoZWxlbSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1B1cmVPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIC8vIE9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAobmVzdGVkLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIG5lc3RlZFtrZXldID0gd3JhcFZhbHVlKHZhbHVlW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZDtcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0cmluZ2lmeVZhbHVlKHZhbHVlKSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRhcHQgTWVpbGlzZWFyY2ggZm9ybWF0dGVkIGZpZWxkcyB0byBhIGZvcm1hdCBjb21wbGlhbnQgdG8gaW5zdGFudHNlYXJjaC5qcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtSZWNvcmQ8c3RyaW5nfSBmb3JtYXR0ZWRIaXRcclxuICAgICAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHtSZWNvcmR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkYXB0Rm9ybWF0dGVkRmllbGRzKGhpdCkge1xyXG4gICAgICAgIGlmICghaGl0KVxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgdmFyIF9mb3JtYXR0ZWRSZXN1bHQgPSB3cmFwVmFsdWUoaGl0KTtcclxuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWRIaXQgPSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIG5vdCBkZXRlcm1pbmUgd2hhdCB0aGUgZGlmZmVyZW5jZXMgYXJlIGJldHdlZW4gdGhvc2UgdHdvIGZpZWxkcy5cclxuICAgICAgICAgICAgX2hpZ2hsaWdodFJlc3VsdDogX2Zvcm1hdHRlZFJlc3VsdCxcclxuICAgICAgICAgICAgX3NuaXBwZXRSZXN1bHQ6IF9mb3JtYXR0ZWRSZXN1bHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBoaWdobGlnaHRlZEhpdDtcclxuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7YW55W119IGhpdHNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRhcHRHZW9SZXNwb25zZShoaXRzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0SUQgPSBcIlwiLmNvbmNhdChpICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xyXG4gICAgICAgICAgICBpZiAoaGl0c1tpXS5fZ2VvKSB7XHJcbiAgICAgICAgICAgICAgICBoaXRzW2ldLl9nZW9sb2MgPSBoaXRzW2ldLl9nZW87XHJcbiAgICAgICAgICAgICAgICBoaXRzW2ldLm9iamVjdElEID0gb2JqZWN0SUQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChfYSA9IGhpdHNbaV0uX2Zvcm1hdHRlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9nZW8pIHtcclxuICAgICAgICAgICAgICAgIGhpdHNbaV0uX2Zvcm1hdHRlZC5fZ2VvbG9jID0gaGl0c1tpXS5fZm9ybWF0dGVkLl9nZW87XHJcbiAgICAgICAgICAgICAgICBoaXRzW2ldLl9mb3JtYXR0ZWQub2JqZWN0SUQgPSBvYmplY3RJRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0cztcclxuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7TWVpbGlTZWFyY2hSZXNwb25zZTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pn0gc2VhcmNoUmVzcG9uc2VcclxuICAgICAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRhcHRIaXRzKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBzZWFyY2hDb250ZXh0LnByaW1hcnlLZXk7XHJcbiAgICAgICAgdmFyIGhpdHMgPSBzZWFyY2hSZXNwb25zZS5oaXRzO1xyXG4gICAgICAgIHZhciBfYSA9IHNlYXJjaENvbnRleHQucGFnaW5hdGlvbiwgZmluaXRlID0gX2EuZmluaXRlLCBoaXRzUGVyUGFnZSA9IF9hLmhpdHNQZXJQYWdlO1xyXG4gICAgICAgIC8vIGlmIHRoZSBsZW5ndGggb2YgdGhlIGhpdHMgaXMgYmlnZ2VyIHRoYW4gdGhlIGhpdHNQZXJQYWdlXHJcbiAgICAgICAgLy8gSXQgbWVhbnMgdGhhdCB0aGVyZSBpcyBzdGlsbCBwYWdlcyB0byBjb21lIGFzIHdlIGFwcGVuZCBsaW1pdCBieSBoaXRzUGVyUGFnZSArIDFcclxuICAgICAgICAvLyBJbiB3aGljaCBjYXNlIHdlIHN0aWxsIG5lZWQgdG8gcmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGhpdCByZXR1cm5lZCBieSBNZWlsaXNlYXJjaFxyXG4gICAgICAgIGlmICghZmluaXRlICYmIGhpdHMubGVuZ3RoID4gaGl0c1BlclBhZ2UpIHtcclxuICAgICAgICAgICAgaGl0cy5zcGxpY2UoaGl0cy5sZW5ndGggLSAxLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFkYXB0ZWRIaXRzID0gaGl0cy5tYXAoZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGVzIEhpdCBvYmplY3QgY29tcGxpYW50IHdpdGggSW5zdGFudFNlYXJjaFxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoaGl0KS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkSGl0ID0gaGl0Ll9mb3JtYXR0ZWQ7IGhpdC5fbWF0Y2hlc1Bvc2l0aW9uOyB2YXIgZG9jdW1lbnRGaWVsZHMgPSBfX3Jlc3QoaGl0LCBbXCJfZm9ybWF0dGVkXCIsIFwiX21hdGNoZXNQb3NpdGlvblwiXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRhcHRlZEhpdCA9IE9iamVjdC5hc3NpZ24oZG9jdW1lbnRGaWVsZHMsIGFkYXB0Rm9ybWF0dGVkRmllbGRzKGZvcm1hdHRlZEhpdCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByaW1hcnlLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGFwdGVkSGl0Lm9iamVjdElEID0gaGl0W3ByaW1hcnlLZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZWRIaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGFwdGVkSGl0cyA9IGFkYXB0R2VvUmVzcG9uc2UoYWRhcHRlZEhpdHMpO1xyXG4gICAgICAgIHJldHVybiBhZGFwdGVkSGl0cztcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkYXB0VG90YWxIaXRzKHNlYXJjaFJlc3BvbnNlKSB7XHJcbiAgICAgICAgdmFyIF9hID0gc2VhcmNoUmVzcG9uc2UuaGl0c1BlclBhZ2UsIGhpdHNQZXJQYWdlID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYSwgX2IgPSBzZWFyY2hSZXNwb25zZS50b3RhbFBhZ2VzLCB0b3RhbFBhZ2VzID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgZXN0aW1hdGVkVG90YWxIaXRzID0gc2VhcmNoUmVzcG9uc2UuZXN0aW1hdGVkVG90YWxIaXRzLCB0b3RhbEhpdHMgPSBzZWFyY2hSZXNwb25zZS50b3RhbEhpdHM7XHJcbiAgICAgICAgaWYgKGVzdGltYXRlZFRvdGFsSGl0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlc3RpbWF0ZWRUb3RhbEhpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRvdGFsSGl0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b3RhbEhpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBzYWZlZ3VhcmRpbmcganVzdCBpbiBjYXNlXHJcbiAgICAgICAgcmV0dXJuIGhpdHNQZXJQYWdlICogdG90YWxQYWdlcztcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkYXB0TmJQYWdlcyhzZWFyY2hSZXNwb25zZSwgaGl0c1BlclBhZ2UpIHtcclxuICAgICAgICBpZiAoc2VhcmNoUmVzcG9uc2UudG90YWxQYWdlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hSZXNwb25zZS50b3RhbFBhZ2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdm9pZCBkaXZpZGluZyBieSAwXHJcbiAgICAgICAgaWYgKGhpdHNQZXJQYWdlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBzZWFyY2hSZXNwb25zZS5saW1pdCwgbGltaXQgPSBfYSA9PT0gdm9pZCAwID8gMjAgOiBfYSwgX2IgPSBzZWFyY2hSZXNwb25zZS5vZmZzZXQsIG9mZnNldCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIGhpdHMgPSBzZWFyY2hSZXNwb25zZS5oaXRzO1xyXG4gICAgICAgIHZhciBhZGRpdGlvbmFsUGFnZSA9IGhpdHMubGVuZ3RoID49IGxpbWl0ID8gMSA6IDA7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCAvIGhpdHNQZXJQYWdlICsgMSArIGFkZGl0aW9uYWxQYWdlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRhcHRQYWdpbmF0aW9uUGFyYW1ldGVycyhzZWFyY2hSZXNwb25zZSwgcGFnaW5hdGlvblN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGhpdHNQZXJQYWdlID0gcGFnaW5hdGlvblN0YXRlLmhpdHNQZXJQYWdlLCBwYWdlID0gcGFnaW5hdGlvblN0YXRlLnBhZ2U7XHJcbiAgICAgICAgdmFyIG5iUGFnZXMgPSBhZGFwdE5iUGFnZXMoc2VhcmNoUmVzcG9uc2UsIGhpdHNQZXJQYWdlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwYWdlOiBwYWdlLFxyXG4gICAgICAgICAgICBuYlBhZ2VzOiBuYlBhZ2VzLFxyXG4gICAgICAgICAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2VcclxuICAgICAgICB9O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBBZGFwdCBzZWFyY2ggcmVzcG9uc2UgZnJvbSBNZWlsaXNlYXJjaFxyXG4gICAgICogdG8gc2VhcmNoIHJlc3BvbnNlIGNvbXBsaWFudCB3aXRoIGluc3RhbnRzZWFyY2guanNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtNZWlsaVNlYXJjaFJlc3BvbnNlPFJlY29yZDxzdHJpbmc+Pn0gc2VhcmNoUmVzcG9uc2VcclxuICAgICAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHt7IHJlc3VsdHM6IEFycmF5PEFsZ29saWFTZWFyY2hSZXNwb25zZTxUPj4gfX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRhcHRTZWFyY2hSZXNwb25zZShzZWFyY2hSZXNwb25zZSwgc2VhcmNoQ29udGV4dCkge1xyXG4gICAgICAgIHZhciBzZWFyY2hSZXNwb25zZU9wdGlvbmFscyA9IHt9O1xyXG4gICAgICAgIHZhciBwcm9jZXNzaW5nVGltZU1zID0gc2VhcmNoUmVzcG9uc2UucHJvY2Vzc2luZ1RpbWVNcywgcXVlcnkgPSBzZWFyY2hSZXNwb25zZS5xdWVyeSwgZmFjZXRzID0gc2VhcmNoUmVzcG9uc2UuZmFjZXREaXN0cmlidXRpb247XHJcbiAgICAgICAgdmFyIF9hID0gYWRhcHRQYWdpbmF0aW9uUGFyYW1ldGVycyhzZWFyY2hSZXNwb25zZSwgc2VhcmNoQ29udGV4dC5wYWdpbmF0aW9uKSwgaGl0c1BlclBhZ2UgPSBfYS5oaXRzUGVyUGFnZSwgcGFnZSA9IF9hLnBhZ2UsIG5iUGFnZXMgPSBfYS5uYlBhZ2VzO1xyXG4gICAgICAgIHZhciBoaXRzID0gYWRhcHRIaXRzKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0KTtcclxuICAgICAgICB2YXIgbmJIaXRzID0gYWRhcHRUb3RhbEhpdHMoc2VhcmNoUmVzcG9uc2UpO1xyXG4gICAgICAgIC8vIENyZWF0ZSByZXNwb25zZSBvYmplY3QgY29tcGxpYW50IHdpdGggSW5zdGFudFNlYXJjaFxyXG4gICAgICAgIHZhciBhZGFwdGVkU2VhcmNoUmVzcG9uc2UgPSBfX2Fzc2lnbih7IGluZGV4OiBzZWFyY2hDb250ZXh0LmluZGV4VWlkLCBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsIHBhZ2U6IHBhZ2UsIGZhY2V0czogZmFjZXRzLCBuYlBhZ2VzOiBuYlBhZ2VzLCBuYkhpdHM6IG5iSGl0cywgcHJvY2Vzc2luZ1RpbWVNUzogcHJvY2Vzc2luZ1RpbWVNcywgcXVlcnk6IHF1ZXJ5LCBoaXRzOiBoaXRzLCBwYXJhbXM6ICcnLCBleGhhdXN0aXZlTmJIaXRzOiBmYWxzZSB9LCBzZWFyY2hSZXNwb25zZU9wdGlvbmFscyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdWx0czogW2FkYXB0ZWRTZWFyY2hSZXNwb25zZV1cclxuICAgICAgICB9O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBhZ2luYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbZmluaXRlXVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbaGl0c1BlclBhZ2VdXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwYWdlXVxyXG4gICAgICogQHJldHVybnMge1NlYXJjaENvbnRleHR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZ2luYXRpb25TdGF0ZShmaW5pdGUsIGhpdHNQZXJQYWdlLCBwYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlID09PSB1bmRlZmluZWQgPyAyMCA6IGhpdHNQZXJQYWdlLFxyXG4gICAgICAgICAgICBwYWdlOiBwYWdlIHx8IDAsXHJcbiAgICAgICAgICAgIGZpbml0ZTogISFmaW5pdGVcclxuICAgICAgICB9O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtBbGdvbGlhTXVsdGlwbGVRdWVyaWVzUXVlcnl9IHNlYXJjaFJlcXVlc3RcclxuICAgICAqIEBwYXJhbSAge0NvbnRleHR9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtTZWFyY2hDb250ZXh0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTZWFyY2hDb250ZXh0KHNlYXJjaFJlcXVlc3QsIG9wdGlvbnMsIGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbikge1xyXG4gICAgICAgIC8vIFNwbGl0IGluZGV4IG5hbWUgYW5kIHBvc3NpYmxlIHNvcnRpbmcgcnVsZXNcclxuICAgICAgICB2YXIgX2EgPSBzZWFyY2hSZXF1ZXN0LmluZGV4TmFtZS5zcGxpdCgnOicpLCBpbmRleFVpZCA9IF9hWzBdLCBzb3J0QnlBcnJheSA9IF9hLnNsaWNlKDEpO1xyXG4gICAgICAgIHZhciBpbnN0YW50U2VhcmNoUGFyYW1zID0gc2VhcmNoUmVxdWVzdC5wYXJhbXM7XHJcbiAgICAgICAgdmFyIHBhZ2luYXRpb25TdGF0ZSA9IGNyZWF0ZVBhZ2luYXRpb25TdGF0ZShvcHRpb25zLmZpbml0ZVBhZ2luYXRpb24sIGluc3RhbnRTZWFyY2hQYXJhbXMgPT09IG51bGwgfHwgaW5zdGFudFNlYXJjaFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFudFNlYXJjaFBhcmFtcy5oaXRzUGVyUGFnZSwgaW5zdGFudFNlYXJjaFBhcmFtcyA9PT0gbnVsbCB8fCBpbnN0YW50U2VhcmNoUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnN0YW50U2VhcmNoUGFyYW1zLnBhZ2UpO1xyXG4gICAgICAgIHZhciBzZWFyY2hDb250ZXh0ID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCBpbnN0YW50U2VhcmNoUGFyYW1zKSwgeyBzb3J0OiBzb3J0QnlBcnJheS5qb2luKCc6JykgfHwgJycsIGluZGV4VWlkOiBpbmRleFVpZCwgcGFnaW5hdGlvbjogcGFnaW5hdGlvblN0YXRlLCBkZWZhdWx0RmFjZXREaXN0cmlidXRpb246IGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbiB8fCB7fSwgcGxhY2Vob2xkZXJTZWFyY2g6IG9wdGlvbnMucGxhY2Vob2xkZXJTZWFyY2ggIT09IGZhbHNlLCBrZWVwWmVyb0ZhY2V0czogISFvcHRpb25zLmtlZXBaZXJvRmFjZXRzIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWFyY2hDb250ZXh0O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtSZWNvcmQ8c3RyaW5nfSBjYWNoZVxyXG4gICAgICogQHJldHVybnMge1NlYXJjaENhY2hlfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTZWFyY2hDYWNoZShjYWNoZSkge1xyXG4gICAgICAgIGlmIChjYWNoZSA9PT0gdm9pZCAwKSB7IGNhY2hlID0ge307IH1cclxuICAgICAgICB2YXIgc2VhcmNoQ2FjaGUgPSBjYWNoZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaENhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzZWFyY2hDYWNoZVtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaENhY2hlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZm9ybWF0S2V5OiBmdW5jdGlvbiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KGNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXRFbnRyeTogZnVuY3Rpb24gKGtleSwgc2VhcmNoUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaENhY2hlW2tleV0gPSBKU09OLnN0cmluZ2lmeShzZWFyY2hSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsZWFyQ2FjaGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaENhY2hlID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FjaGVGaXJzdEZhY2V0RGlzdHJpYnV0aW9uKHNlYXJjaFJlc29sdmVyLCBzZWFyY2hDb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFNlYXJjaENvbnRleHQsIG1laWxpc2VhcmNoUGFyYW1zLCBzZWFyY2hSZXNwb25zZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFNlYXJjaENvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2VhcmNoQ29udGV4dCksIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlcnNlYXJjaCB0cnVlIHRvIGVuc3VyZSBhIHJlcXVlc3QgaXMgbWFkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJTZWFyY2g6IHRydWUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgc2V0IHRvIGVtcHR5IHRvIGVuc3VyZSByZXRyaWV2aW5nIHRoZSBkZWZhdWx0IGZhY2V0ZGlzdHJpYnV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogJycgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1laWxpc2VhcmNoUGFyYW1zID0gTWVpbGlQYXJhbXNDcmVhdG9yKGRlZmF1bHRTZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkRmFjZXRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZFBhZ2luYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2VhcmNoUmVzb2x2ZXIuc2VhcmNoUmVzcG9uc2UoZGVmYXVsdFNlYXJjaENvbnRleHQsIG1laWxpc2VhcmNoUGFyYW1zLmdldFBhcmFtcygpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlYXJjaFJlc3BvbnNlLmZhY2V0RGlzdHJpYnV0aW9uIHx8IHt9XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XG5cbiAgICB2YXIgUEFDS0FHRV9WRVJTSU9OID0gJzAuMTAuMSc7XG5cbiAgICB2YXIgY29uc3RydWN0Q2xpZW50QWdlbnRzID0gZnVuY3Rpb24gKGNsaWVudEFnZW50cykge1xyXG4gICAgICAgIGlmIChjbGllbnRBZ2VudHMgPT09IHZvaWQgMCkgeyBjbGllbnRBZ2VudHMgPSBbXTsgfVxyXG4gICAgICAgIHZhciBpbnN0YW50TWVpbGlzZWFyY2hBZ2VudCA9IFwiTWVpbGlzZWFyY2ggaW5zdGFudC1tZWlsaXNlYXJjaCAodlwiLmNvbmNhdChQQUNLQUdFX1ZFUlNJT04sIFwiKVwiKTtcclxuICAgICAgICByZXR1cm4gY2xpZW50QWdlbnRzLmNvbmNhdChpbnN0YW50TWVpbGlzZWFyY2hBZ2VudCk7XHJcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBhcGlLZXkgY2FsbGJhY2sgZGVmaW5pdGlvblxyXG4gICAgICogQGNhbGxiYWNrIGFwaUtleUNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBhcGlLZXkgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgU2VhcmNoQ2xpZW50IHJlcXVpcmVkIGJ5IGluc3RhbnRzZWFyY2guanMuXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGhvc3RVcmxcclxuICAgICAqIEBwYXJhbSAge3N0cmluZyB8IGFwaUtleUNhbGxiYWNrfSBhcGlLZXlcclxuICAgICAqIEBwYXJhbSAge0luc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnM9e319IG1laWxpU2VhcmNoT3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge0luc3RhbnRNZWlsaVNlYXJjaEluc3RhbmNlfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbnN0YW50TWVpbGlTZWFyY2goaG9zdFVybCwgYXBpS2V5LCBpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PT0gdm9pZCAwKSB7IGFwaUtleSA9ICcnOyB9XHJcbiAgICAgICAgaWYgKGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zID0ge307IH1cclxuICAgICAgICAvLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgdmFsaWRhdGVJbnN0YW50TWVpbGlTZWFyY2hQYXJhbXMoaG9zdFVybCwgYXBpS2V5KTtcclxuICAgICAgICAvLyBSZXNvbHZlIHBvc3NpYmxlIGZ1bmN0aW9uIHRvIGdldCBhcGlLZXlcclxuICAgICAgICBhcGlLZXkgPSBnZXRBcGlLZXkoYXBpS2V5KTtcclxuICAgICAgICB2YXIgY2xpZW50QWdlbnRzID0gY29uc3RydWN0Q2xpZW50QWdlbnRzKGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMuY2xpZW50QWdlbnRzKTtcclxuICAgICAgICB2YXIgbWVpbGlzZWFyY2hDbGllbnQgPSBuZXcgbWVpbGlzZWFyY2hfdW1kLk1laWxpU2VhcmNoKHtcclxuICAgICAgICAgICAgaG9zdDogaG9zdFVybCxcclxuICAgICAgICAgICAgYXBpS2V5OiBhcGlLZXksXHJcbiAgICAgICAgICAgIGNsaWVudEFnZW50czogY2xpZW50QWdlbnRzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHNlYXJjaENhY2hlID0gU2VhcmNoQ2FjaGUoKTtcclxuICAgICAgICAvLyBjcmVhdGUgc2VhcmNoIHJlc29sdmVyIHdpdGggaW5jbHVkZWQgY2FjaGVcclxuICAgICAgICB2YXIgc2VhcmNoUmVzb2x2ZXIgPSBTZWFyY2hSZXNvbHZlcihtZWlsaXNlYXJjaENsaWVudCwgc2VhcmNoQ2FjaGUpO1xyXG4gICAgICAgIHZhciBkZWZhdWx0RmFjZXREaXN0cmlidXRpb247XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2xlYXJDYWNoZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VhcmNoQ2FjaGUuY2xlYXJDYWNoZSgpOyB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtICB7cmVhZG9ubHlBbGdvbGlhTXVsdGlwbGVRdWVyaWVzUXVlcnlbXX0gaW5zdGFudFNlYXJjaFJlcXVlc3RzXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKGluc3RhbnRTZWFyY2hSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hSZXF1ZXN0LCBzZWFyY2hDb250ZXh0LCBhZGFwdGVkU2VhcmNoUmVxdWVzdCwgc2VhcmNoUmVzcG9uc2UsIGFkYXB0ZWRTZWFyY2hSZXNwb25zZSwgZV8xO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgNCwgLCA1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUmVxdWVzdCA9IGluc3RhbnRTZWFyY2hSZXF1ZXN0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0ID0gY3JlYXRlU2VhcmNoQ29udGV4dChzZWFyY2hSZXF1ZXN0LCBpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zLCBkZWZhdWx0RmFjZXREaXN0cmlidXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0ZWRTZWFyY2hSZXF1ZXN0ID0gYWRhcHRTZWFyY2hQYXJhbXMoc2VhcmNoQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uID09PSB1bmRlZmluZWQpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjYWNoZUZpcnN0RmFjZXREaXN0cmlidXRpb24oc2VhcmNoUmVzb2x2ZXIsIHNlYXJjaENvbnRleHQpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RmFjZXREaXN0cmlidXRpb24gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoQ29udGV4dC5kZWZhdWx0RmFjZXREaXN0cmlidXRpb24gPSBkZWZhdWx0RmFjZXREaXN0cmlidXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBzZWFyY2hSZXNvbHZlci5zZWFyY2hSZXNwb25zZShzZWFyY2hDb250ZXh0LCBhZGFwdGVkU2VhcmNoUmVxdWVzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGFwdCB0aGUgTWVpbGlzZWFyY2ggcmVzcG9uc25lIHRvIGEgY29tcGxpYW50IGluc3RhbnRzZWFyY2guanMgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRlZFNlYXJjaFJlc3BvbnNlID0gYWRhcHRTZWFyY2hSZXNwb25zZShzZWFyY2hSZXNwb25zZSwgc2VhcmNoQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFkYXB0ZWRTZWFyY2hSZXNwb25zZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VhcmNoRm9yRmFjZXRWYWx1ZXM6IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU2VhcmNoRm9yRmFjZXRWYWx1ZXMgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBNZWlsaXNlYXJjaCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7IC8vIGFkZGVkIGhlcmUgdG8gYXZvaWQgY29tcGlsYXRpb24gZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIGFwaUtleSBpZiBpdCBpcyBhIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmcgfCBhcGlLZXlDYWxsYmFja30gYXBpS2V5XHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBhcGkga2V5IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEFwaUtleShhcGlLZXkpIHtcclxuICAgICAgICAvLyBJZiBhcGlLZXkgaXMgZnVuY3Rpb24sIGNhbGwgaXQgdG8gZ2V0IHRoZSBhcGlLZXlcclxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgYXBpS2V5Rm5WYWx1ZSA9IGFwaUtleSgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFwaUtleUZuVmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBhcGlLZXkgZnVuY3Rpb24gKDJuZCBwYXJhbWV0ZXIpIGRpZCBub3QgcmV0dXJuIGEgc3RyaW5nLCBleHBlY3RlZCBzdHJpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXBpS2V5Rm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcclxuICAgIH1cblxuICAgIGV4cG9ydHMuTWF0Y2hpbmdTdHJhdGVnaWVzID0gdm9pZCAwO1xyXG4gICAgKGZ1bmN0aW9uIChNYXRjaGluZ1N0cmF0ZWdpZXMpIHtcclxuICAgICAgICBNYXRjaGluZ1N0cmF0ZWdpZXNbXCJBTExcIl0gPSBcImFsbFwiO1xyXG4gICAgICAgIE1hdGNoaW5nU3RyYXRlZ2llc1tcIkxBU1RcIl0gPSBcImxhc3RcIjtcclxuICAgIH0pKGV4cG9ydHMuTWF0Y2hpbmdTdHJhdGVnaWVzIHx8IChleHBvcnRzLk1hdGNoaW5nU3RyYXRlZ2llcyA9IHt9KSk7XG5cbiAgICBleHBvcnRzLmluc3RhbnRNZWlsaVNlYXJjaCA9IGluc3RhbnRNZWlsaVNlYXJjaDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.js\n"));

/***/ }),

/***/ "./src/components/Header.jsx":
/*!***********************************!*\
  !*** ./src/components/Header.jsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _fortawesome_react_fontawesome__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fortawesome/react-fontawesome */ \"./node_modules/@fortawesome/react-fontawesome/index.es.js\");\n/* harmony import */ var _fortawesome_free_solid_svg_icons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fortawesome/free-solid-svg-icons */ \"./node_modules/@fortawesome/free-solid-svg-icons/index.mjs\");\n/* harmony import */ var _assets_images_icon_logo_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/images/icon-logo.png */ \"./src/assets/images/icon-logo.png\");\n/* harmony import */ var _assets_images_logo_ibisnis_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assets/images/logo-ibisnis.png */ \"./src/assets/images/logo-ibisnis.png\");\n/* harmony import */ var _meilisearch_instant_meilisearch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @meilisearch/instant-meilisearch */ \"./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.js\");\n/* harmony import */ var _meilisearch_instant_meilisearch__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_meilisearch_instant_meilisearch__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\nfunction Header() {\n    var searchClient = (0,_meilisearch_instant_meilisearch__WEBPACK_IMPORTED_MODULE_6__.instantMeiliSearch)(\"https://integration-demos.meilisearch.com\", {\n        primaryKey: \"id\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed z-20 flex justify-between top-0 left-0 w-full bg-white shadow-md\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex justify-between w-full lg:justify-start lg:w-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"pr-2\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            width: \"55\",\n                            height: \"55\",\n                            src: _assets_images_icon_logo_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n                            alt: \"\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                            lineNumber: 24,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 23,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"p-2\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            className: \"mt-3\",\n                            width: \"70\",\n                            height: \"70\",\n                            src: _assets_images_logo_ibisnis_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                            alt: \"\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                            lineNumber: 32,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 31,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"p-2 flex items-center mx-3 border-cyan-100 rounded-md\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                className: \"hidden lg:block border-y-2 border-l-2 border-r-2 border-gray-200 py-1 px-3 rounded-l-lg absolute lg:relative lg:border-r-0\",\n                                type: \"search\",\n                                name: \"\",\n                                id: \"\",\n                                placeholder: \"Search Keyword\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                lineNumber: 41,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"lg:border-y-2 lg:border-r-2 lg:border-gray-200 p-1 px-2 rounded-r-lg\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fortawesome_react_fontawesome__WEBPACK_IMPORTED_MODULE_3__.FontAwesomeIcon, {\n                                    icon: _fortawesome_free_solid_svg_icons__WEBPACK_IMPORTED_MODULE_7__.faSearch\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                    lineNumber: 49,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                lineNumber: 48,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 40,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                lineNumber: 22,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"hidden lg:flex lg:items-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                        name: \"\",\n                        id: \"\",\n                        className: \"border-0 mx-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                value: \"Surabaya\",\n                                children: \"Surabaya\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                lineNumber: 55,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                value: \"Jakarta\",\n                                children: \"Jakarta\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                lineNumber: 56,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 54,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-gray-500 mx-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fortawesome_react_fontawesome__WEBPACK_IMPORTED_MODULE_3__.FontAwesomeIcon, {\n                                icon: _fortawesome_free_solid_svg_icons__WEBPACK_IMPORTED_MODULE_7__.faLanguage\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                lineNumber: 59,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                name: \"\",\n                                className: \"border-0 text-gray-500\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: \"\",\n                                        children: \"Language\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                        lineNumber: 61,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: \"IND\",\n                                        children: \"Indonesia\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                        lineNumber: 62,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                                lineNumber: 60,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 58,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"p-2\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            href: \"https://ibisnis.com/login\",\n                            className: \"border-2 border-red-500 rounded-lg text-red-500 px-3 py-2 mt-5\",\n                            children: \"Login\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                            lineNumber: 66,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 65,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                        href: \"https://ibisnis.com/register\",\n                        className: \"bg-red-600 text-white px-6 py-4\",\n                        children: \"Get Invited\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                        lineNumber: 73,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n                lineNumber: 53,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\ARYO\\\\Documents\\\\ibisnis_react\\\\src\\\\components\\\\Header.jsx\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, this);\n}\n_c = Header;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Header);\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9IZWFkZXIuanN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFnRDtBQUNqQjtBQUNrQztBQUl0QjtBQUNNO0FBQ1c7QUFDUztBQUVyRSxTQUFTVSxTQUFTO0lBRWQsSUFBTUMsZUFBZUYsb0ZBQWtCQSxDQUNuQyw2Q0FDQTtRQUNFRyxZQUFZO0lBQ2Q7SUFFTixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNYLG1EQUFLQTs0QkFDSlksT0FBTTs0QkFDTkMsUUFBTzs0QkFDUEMsS0FBS1Ysb0VBQUlBOzRCQUNUVyxLQUFJOzs7Ozs7Ozs7OztrQ0FHUiw4REFBQ0w7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNYLG1EQUFLQTs0QkFDSlcsV0FBVTs0QkFDVkMsT0FBTTs0QkFDTkMsUUFBTzs0QkFDUEMsS0FBS1QsdUVBQVlBOzRCQUNqQlUsS0FBSTs7Ozs7Ozs7Ozs7a0NBR1IsOERBQUNMO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ0s7Z0NBQ0NMLFdBQVU7Z0NBQ1ZNLE1BQUs7Z0NBQ0xDLE1BQUs7Z0NBQ0xDLElBQUc7Z0NBQ0hDLGFBQVk7Ozs7OzswQ0FFZCw4REFBQ1Y7Z0NBQUlDLFdBQVU7MENBQ2IsNEVBQUNWLDJFQUFlQTtvQ0FBQ29CLE1BQU1uQix1RUFBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUlyQyw4REFBQ1E7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDVzt3QkFBT0osTUFBSzt3QkFBR0MsSUFBRzt3QkFBR1IsV0FBVTs7MENBQzlCLDhEQUFDWTtnQ0FBT0MsT0FBTTswQ0FBVzs7Ozs7OzBDQUN6Qiw4REFBQ0Q7Z0NBQU9DLE9BQU07MENBQVU7Ozs7Ozs7Ozs7OztrQ0FFMUIsOERBQUNkO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ1YsMkVBQWVBO2dDQUFDb0IsTUFBTWxCLHlFQUFVQTs7Ozs7OzBDQUNqQyw4REFBQ21CO2dDQUFPSixNQUFLO2dDQUFHUCxXQUFVOztrREFDeEIsOERBQUNZO3dDQUFPQyxPQUFNO2tEQUFHOzs7Ozs7a0RBQ2pCLDhEQUFDRDt3Q0FBT0MsT0FBTTtrREFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUd4Qiw4REFBQ2Q7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNjOzRCQUNDQyxNQUFLOzRCQUNMZixXQUFVO3NDQUNYOzs7Ozs7Ozs7OztrQ0FJSCw4REFBQ2M7d0JBQ0NDLE1BQUs7d0JBQ0xmLFdBQVU7a0NBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1UO0tBdEVTSjtBQXVFVCwrREFBZUEsTUFBTUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9IZWFkZXIuanN4PzNjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZUVmZmVjdH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcclxuaW1wb3J0IHsgRm9udEF3ZXNvbWVJY29uIH0gZnJvbSBcIkBmb3J0YXdlc29tZS9yZWFjdC1mb250YXdlc29tZVwiO1xyXG5pbXBvcnQge1xyXG4gIGZhU2VhcmNoLFxyXG4gIGZhTGFuZ3VhZ2VcclxufSBmcm9tIFwiQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zXCI7XHJcbmltcG9ydCBsb2dvIGZyb20gJy4uL2Fzc2V0cy9pbWFnZXMvaWNvbi1sb2dvLnBuZydcclxuaW1wb3J0IGxvZ29faWJpc25pcyBmcm9tICcuLi9hc3NldHMvaW1hZ2VzL2xvZ28taWJpc25pcy5wbmcnXHJcbmltcG9ydCB7IGluc3RhbnRNZWlsaVNlYXJjaCB9IGZyb20gJ0BtZWlsaXNlYXJjaC9pbnN0YW50LW1laWxpc2VhcmNoJ1xyXG5cclxuZnVuY3Rpb24gSGVhZGVyKCkge1xyXG5cclxuICAgIGNvbnN0IHNlYXJjaENsaWVudCA9IGluc3RhbnRNZWlsaVNlYXJjaChcclxuICAgICAgICAnaHR0cHM6Ly9pbnRlZ3JhdGlvbi1kZW1vcy5tZWlsaXNlYXJjaC5jb20nLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByaW1hcnlLZXk6ICdpZCdcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmaXhlZCB6LTIwIGZsZXgganVzdGlmeS1iZXR3ZWVuIHRvcC0wIGxlZnQtMCB3LWZ1bGwgYmctd2hpdGUgc2hhZG93LW1kXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gdy1mdWxsIGxnOmp1c3RpZnktc3RhcnQgbGc6dy1hdXRvXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwci0yXCI+XHJcbiAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgd2lkdGg9XCI1NVwiXHJcbiAgICAgICAgICAgIGhlaWdodD1cIjU1XCJcclxuICAgICAgICAgICAgc3JjPXtsb2dvfVxyXG4gICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtMlwiPlxyXG4gICAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTNcIlxyXG4gICAgICAgICAgICB3aWR0aD1cIjcwXCJcclxuICAgICAgICAgICAgaGVpZ2h0PVwiNzBcIlxyXG4gICAgICAgICAgICBzcmM9e2xvZ29faWJpc25pc31cclxuICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTIgZmxleCBpdGVtcy1jZW50ZXIgbXgtMyBib3JkZXItY3lhbi0xMDAgcm91bmRlZC1tZFwiPlxyXG4gICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImhpZGRlbiBsZzpibG9jayBib3JkZXIteS0yIGJvcmRlci1sLTIgYm9yZGVyLXItMiBib3JkZXItZ3JheS0yMDAgcHktMSBweC0zIHJvdW5kZWQtbC1sZyBhYnNvbHV0ZSBsZzpyZWxhdGl2ZSBsZzpib3JkZXItci0wXCJcclxuICAgICAgICAgICAgdHlwZT1cInNlYXJjaFwiXHJcbiAgICAgICAgICAgIG5hbWU9XCJcIlxyXG4gICAgICAgICAgICBpZD1cIlwiXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VhcmNoIEtleXdvcmRcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGc6Ym9yZGVyLXktMiBsZzpib3JkZXItci0yIGxnOmJvcmRlci1ncmF5LTIwMCBwLTEgcHgtMiByb3VuZGVkLXItbGdcIj5cclxuICAgICAgICAgICAgPEZvbnRBd2Vzb21lSWNvbiBpY29uPXtmYVNlYXJjaH0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoaWRkZW4gbGc6ZmxleCBsZzppdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICA8c2VsZWN0IG5hbWU9XCJcIiBpZD1cIlwiIGNsYXNzTmFtZT1cImJvcmRlci0wIG14LTNcIj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJTdXJhYmF5YVwiPlN1cmFiYXlhPC9vcHRpb24+XHJcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiSmFrYXJ0YVwiPkpha2FydGE8L29wdGlvbj5cclxuICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDAgbXgtM1wiPlxyXG4gICAgICAgICAgPEZvbnRBd2Vzb21lSWNvbiBpY29uPXtmYUxhbmd1YWdlfSAvPlxyXG4gICAgICAgICAgPHNlbGVjdCBuYW1lPVwiXCIgY2xhc3NOYW1lPVwiYm9yZGVyLTAgdGV4dC1ncmF5LTUwMFwiPlxyXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+TGFuZ3VhZ2U8L29wdGlvbj5cclxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIklORFwiPkluZG9uZXNpYTwvb3B0aW9uPlxyXG4gICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTJcIj5cclxuICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgIGhyZWY9XCJodHRwczovL2liaXNuaXMuY29tL2xvZ2luXCJcclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyLTIgYm9yZGVyLXJlZC01MDAgcm91bmRlZC1sZyB0ZXh0LXJlZC01MDAgcHgtMyBweS0yIG10LTVcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICBMb2dpblxyXG4gICAgICAgICAgPC9hPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxhXHJcbiAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9pYmlzbmlzLmNvbS9yZWdpc3RlclwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHgtNiBweS00XCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICBHZXQgSW52aXRlZFxyXG4gICAgICAgIDwvYT5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEhlYWRlciJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiSW1hZ2UiLCJGb250QXdlc29tZUljb24iLCJmYVNlYXJjaCIsImZhTGFuZ3VhZ2UiLCJsb2dvIiwibG9nb19pYmlzbmlzIiwiaW5zdGFudE1laWxpU2VhcmNoIiwiSGVhZGVyIiwic2VhcmNoQ2xpZW50IiwicHJpbWFyeUtleSIsImRpdiIsImNsYXNzTmFtZSIsIndpZHRoIiwiaGVpZ2h0Iiwic3JjIiwiYWx0IiwiaW5wdXQiLCJ0eXBlIiwibmFtZSIsImlkIiwicGxhY2Vob2xkZXIiLCJpY29uIiwic2VsZWN0Iiwib3B0aW9uIiwidmFsdWUiLCJhIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Header.jsx\n"));

/***/ })

});